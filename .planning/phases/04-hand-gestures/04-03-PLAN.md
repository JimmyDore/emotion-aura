---
phase: 04-hand-gestures
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/particles/ParticlePool.ts
  - src/main.ts
  - src/style.css
autonomous: false

must_haves:
  truths:
    - "Open hand pushes particles outward in a radial explosion from the palm position"
    - "Closed fist attracts particles in a tightening spiral toward the fist"
    - "Pinch concentrates particles in a rapid vortex funnel toward the pinch point"
    - "Gesture forces override emotion-driven particle velocity while active, emotion forces resume after gesture ends"
    - "Gesture overlay shows current gesture, hand aura shows force field radius"
    - "When hand covers face, last emotion state is frozen (not decayed to neutral)"
  artifacts:
    - path: "src/particles/ParticlePool.ts"
      provides: "applyForceField() method for gesture-driven particle manipulation"
      contains: "applyForceField"
    - path: "src/main.ts"
      provides: "Full gesture pipeline integration: classify -> stabilize -> force field -> UI"
      contains: "gestureState"
  key_links:
    - from: "src/main.ts"
      to: "src/particles/ParticlePool.ts"
      via: "particlePool.applyForceField() called when gesture active"
      pattern: "applyForceField"
    - from: "src/main.ts"
      to: "src/ml/GestureClassifier.ts"
      via: "classifyGesture() and getPalmCenter() on hand landmarks"
      pattern: "classifyGesture"
    - from: "src/main.ts"
      to: "src/state/GestureState.ts"
      via: "gestureState.update() every frame"
      pattern: "gestureState\\.update"
    - from: "src/main.ts"
      to: "src/ui/GestureOverlay.ts"
      via: "gestureOverlay.update() every frame"
      pattern: "gestureOverlay\\.update"
---

<objective>
Wire the complete gesture-to-particle pipeline: force fields in ParticlePool, hand aura visualization, gesture override logic, occlusion handling, and full main.ts integration with human verification.

Purpose: Complete Phase 4 by connecting hand detection -> gesture classification -> particle manipulation, creating interactive hand-driven particle control.
Output: Working gesture-to-particle force fields, visible hand aura, gesture indicator, and a verified interactive experience.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-hand-gestures/04-CONTEXT.md
@.planning/phases/04-hand-gestures/04-RESEARCH.md
@.planning/phases/04-hand-gestures/04-01-SUMMARY.md
@.planning/phases/04-hand-gestures/04-02-SUMMARY.md

@src/main.ts
@src/particles/ParticlePool.ts
@src/particles/ParticleSystem.ts
@src/particles/FaceLandmarkTracker.ts
@src/ml/GestureClassifier.ts
@src/state/GestureState.ts
@src/ui/GestureOverlay.ts
@src/core/constants.ts
@src/core/types.ts
@src/style.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add applyForceField() to ParticlePool</name>
  <files>src/particles/ParticlePool.ts</files>
  <action>
Add a public `applyForceField()` method to `ParticlePool`. This applies gesture-driven velocity modifications to particles within the influence radius. Forces apply at full strength immediately when a gesture activates (instant onset, punchy arcade feel -- user decision). Only particle velocity/position is affected by force fields -- particle colors remain emotion-driven at all times (user decision).

Import GestureType at the top:
```typescript
import type { GestureType } from '../core/types.ts';
```

Add method after `update()`:

```typescript
/**
 * Apply a gesture-driven force field to all active particles within radius.
 * Called from main.ts when a gesture is active.
 *
 * Force behaviors (user decisions):
 * - push: radial outward explosion from hand position
 * - attract: spiral inward (tangential + radial) toward hand
 * - pinch: vortex funnel (strong tangential + strong inward convergence)
 */
applyForceField(
  handX: number,
  handY: number,
  gestureType: GestureType,
  radius: number,
  strength: number,
  dt: number,
): void {
  for (let i = 0; i < this.activeCount; i++) {
    const i3 = i * 3;
    const dx = this.positions[i3] - handX;
    const dy = this.positions[i3 + 1] - handY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > radius || dist < 0.001) continue;

    const t = 1.0 - dist / radius; // 1 at center, 0 at edge
    const force = strength * t * t; // Quadratic falloff

    const nx = dx / dist;
    const ny = dy / dist;

    switch (gestureType) {
      case 'push': {
        // Radial outward explosion -- punchy, explosive (user decision)
        this.velocities[i3]     += nx * force * dt;
        this.velocities[i3 + 1] += ny * force * dt;
        break;
      }
      case 'attract': {
        // Spiral inward: 60% radial pull + 40% tangential rotation
        this.velocities[i3]     -= nx * force * 0.6 * dt;
        this.velocities[i3 + 1] -= ny * force * 0.6 * dt;
        // Tangential component (perpendicular, creates spiral orbit)
        this.velocities[i3]     += (-ny) * force * 0.4 * dt;
        this.velocities[i3 + 1] += nx * force * 0.4 * dt;
        break;
      }
      case 'pinch': {
        // Vortex funnel: 70% strong inward + 80% fast rotation (tornado-like)
        this.velocities[i3]     -= nx * force * 0.7 * dt;
        this.velocities[i3 + 1] -= ny * force * 0.7 * dt;
        this.velocities[i3]     += (-ny) * force * 0.8 * dt;
        this.velocities[i3 + 1] += nx * force * 0.8 * dt;
        break;
      }
    }
  }
}
```

This iterates only active particles (contiguous region), applies quadratic falloff, and is frame-rate independent via `dt` multiplication. The `'none'` gesture type will never be passed (caller checks `active` first), so no case needed.
  </action>
  <verify>`npx tsc --noEmit` passes.</verify>
  <done>ParticlePool has applyForceField() with radial push, spiral attract, and vortex pinch force behaviors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire complete gesture pipeline in main.ts</name>
  <files>src/main.ts, src/style.css</files>
  <action>
This is the integration task. Wire gesture classification, state, force fields, overlay, hand aura, and occlusion handling into main.ts. IMPORTANT: Gesture forces only affect particle velocity/position -- particle colors MUST remain emotion-driven at all times (user decision). Spawning position stays face-anchored regardless of gesture state.

**1. Add imports:**
```typescript
import { classifyGesture, getPalmCenter } from './ml/GestureClassifier.ts';
import { GestureState } from './state/GestureState.ts';
import { GestureOverlay } from './ui/GestureOverlay.ts';
import { GESTURE_INFLUENCE_PX, FORCE_PUSH_STRENGTH, FORCE_ATTRACT_STRENGTH, FORCE_PINCH_STRENGTH } from './core/constants.ts';
import type { GestureType } from './core/types.ts';
```

**2. Add module-level variables** (next to existing `emotionOverlay`, etc.):
```typescript
let gestureOverlay: GestureOverlay | null = null;
let handAura: HTMLDivElement | null = null;
```

**3. In `loadAndConnect()`, after creating emotionOverlay and before particle system setup, add:**
```typescript
// Gesture pipeline
const gestureState = new GestureState();
gestureOverlay = new GestureOverlay(app);
```

Create the hand aura div:
```typescript
// Hand aura: positioned div showing force field radius
handAura = document.createElement('div');
handAura.className = 'hand-aura';
app.appendChild(handAura);
```

IMPORTANT: `gestureState` is used inside `animate()`, so it must be declared in the same scope as the other state variables (inside `loadAndConnect`, before `animate`). This is the same pattern as `emotionState`.

**4. Replace the hand frame branch in the staggered inference block (from Plan 04-01):**

The Plan 04-01 code has:
```typescript
} else {
  // HAND frame (odd) -- detection only, processing deferred to Plan 04-03
  const handResultData = handDetector!.detect(video!);
  void handResultData;
}
```

Replace with:
```typescript
} else {
  // HAND frame (odd)
  const handResultData = handDetector!.detect(video!);
  if (handResultData !== null && handResultData.landmarks.length > 0) {
    const landmarks = handResultData.landmarks[0];
    const rawGesture = classifyGesture(landmarks);
    const palmCenter = getPalmCenter(landmarks);

    // Convert palm center to scene coordinates (same as FaceLandmarkTracker.toScene)
    const palmSceneX = -(palmCenter.x * 2 - 1) * aspect;
    const palmSceneY = -(palmCenter.y * 2 - 1);

    gestureState.update(rawGesture, true, { x: palmSceneX, y: palmSceneY }, dt);
  } else {
    gestureState.update('none', false, null, dt);
  }
}
```

**5. Add occlusion handling in the face frame branch:**

In the face frame block, when face is NOT detected (the `else` branch of `result.faceBlendshapes?.length > 0`), check if hand is currently detected:

Modify the face-lost branch:
```typescript
} else {
  // Face lost
  const gestureResult = gestureState.getCurrent();
  if (gestureResult.active && gestureResult.handPosition) {
    // Occlusion: hand present + face lost = freeze last emotion (don't decay)
    // Keep lastFaceLandmarks as-is (don't set to undefined)
  } else {
    emotionState.decayToNeutral();
    lastFaceLandmarks = undefined;
  }
}
```

**6. After the spawn/update section but BEFORE `particleSystem!.update(dt, now)`, add force field application:**

```typescript
// ── Gesture force fields ──────────────────────────────────────────
const gestureResult = gestureState.getCurrent();

if (gestureResult.active && gestureResult.handPosition) {
  // Determine force strength based on gesture type
  const forceStrengths: Record<GestureType, number> = {
    push: FORCE_PUSH_STRENGTH,
    attract: FORCE_ATTRACT_STRENGTH,
    pinch: FORCE_PINCH_STRENGTH,
    none: 0,
  };
  const baseStrength = forceStrengths[gestureResult.gesture];
  const effectiveStrength = baseStrength * gestureResult.strength; // strength decays on hand loss

  // Influence radius: convert pixels to scene units
  const influenceRadius = (GESTURE_INFLUENCE_PX / window.innerHeight) * 2.0;

  particleSystem!.getPool().applyForceField(
    gestureResult.handPosition.x,
    gestureResult.handPosition.y,
    gestureResult.gesture,
    influenceRadius,
    effectiveStrength,
    dt,
  );
}
```

**7. Update gesture overlay and hand aura every frame** (add after emotionOverlay update):
```typescript
// Update gesture overlay
gestureOverlay!.update(gestureResult.gesture);

// Update hand aura position and visibility
if (handAura) {
  if (gestureResult.active && gestureResult.handPosition) {
    // Convert scene coords back to screen coords for DOM positioning
    // Scene: x=[-aspect, aspect], y=[-1, 1]. Screen: [0, viewportWidth], [0, viewportHeight]
    const screenX = (1 - (gestureResult.handPosition.x / aspect + 1) / 2) * window.innerWidth;
    const screenY = (1 - (gestureResult.handPosition.y + 1) / 2) * window.innerHeight;
    const auraSizePx = GESTURE_INFLUENCE_PX * 2; // diameter

    handAura.style.left = `${screenX}px`;
    handAura.style.top = `${screenY}px`;
    handAura.style.width = `${auraSizePx}px`;
    handAura.style.height = `${auraSizePx}px`;
    handAura.classList.add('hand-aura--visible');
  } else {
    handAura.classList.remove('hand-aura--visible');
  }
}
```

**8. Gesture override for particle velocity:**

The user decision states gesture forces override emotion-driven particle behavior COMPLETELY while active. The spawning (position, colors) stays emotion-driven, but the velocity from emotion profile should be suppressed when a gesture is active.

In the particle spawning section, wrap the velocity computation. When gesture is active, reduce the emotion-driven initial velocity so particles are more susceptible to the force field:

Find the line:
```typescript
const speed = profile.speed * (0.5 + Math.random() * 0.5) * (0.5 + intensity * 0.5);
```

Replace with:
```typescript
// When gesture active: reduce initial velocity so force fields dominate
const gestureActive = gestureResult.active;
const speedScale = gestureActive ? 0.2 : 1.0;
const speed = profile.speed * (0.5 + Math.random() * 0.5) * (0.5 + intensity * 0.5) * speedScale;
```

This ensures particles still spawn with slight initial motion but are easily redirected by the force field.

**9. Add HMR cleanup:**
```typescript
if (gestureOverlay) {
  gestureOverlay.dispose();
  gestureOverlay = null;
}
if (handAura) {
  handAura.remove();
  handAura = null;
}
```

**10. Ensure the `gestureResult` variable is accessible throughout the frame:**

Since `gestureResult` is needed both in the spawn section and in the force field/UI section, declare it early in `animate()` and update it:

After the staggered inference block (which calls `gestureState.update()`), add:
```typescript
const gestureResult = gestureState.getCurrent();
```

Then reference this single variable everywhere else in the frame.
  </action>
  <verify>
1. `npx tsc --noEmit` passes.
2. `npx vite build` completes.
3. Manual browser test: Open hand near camera -- particles should push away. Close fist -- particles spiral inward. Pinch -- particles vortex to a point.
  </verify>
  <done>Complete gesture-to-particle pipeline integrated: hand detection -> gesture classification -> stability -> force field -> UI overlay + aura. Occlusion handling freezes emotion when hand covers face. Gesture forces override emotion velocity while active.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete hand gesture particle manipulation:
- Open hand pushes particles away (radial explosion)
- Closed fist attracts particles (spiral inward)
- Pinch concentrates particles (vortex funnel)
- Gesture indicator visible at top-left showing current gesture
- Subtle aura/glow around hand showing force field radius
- Gestures override emotion particle behavior while active
- Emotion-driven spawning and colors continue during gestures
- ~150ms stability delay prevents gesture flicker during transitions
  </what-built>
  <how-to-verify>
1. Run `npx vite` and open http://localhost:5173 in Chrome
2. **Face check:** Verify emotion overlay (top-right) still shows correct emotions. Make expressions -- particles should still react to emotion.
3. **Open hand (push):** Hold your open hand in view. After a brief moment (~150ms), the gesture indicator (top-left) should show "push" and particles near your hand should fly outward explosively. A subtle glow should appear around your hand.
4. **Closed fist (attract):** Make a fist. Gesture indicator should change to "attract". Particles should spiral inward toward your fist.
5. **Pinch (concentrate):** Pinch thumb and index finger together. Gesture indicator should show "concentrate". Particles should swirl into a tight vortex at the pinch point.
6. **Stability:** Transition between gestures -- there should be NO flickering of the indicator. Brief pause (~150ms) before new gesture activates.
7. **Hand exit:** Move your hand out of frame. Force effect should fade smoothly (~300ms), particles return to emotion-driven behavior.
8. **Occlusion:** Place your hand in front of your face. Emotion should freeze (not drop to neutral). Move hand away -- face detection resumes.
9. **Performance:** Check FPS counter (top-left stats). Should stay at 30+ FPS with both face and hand detection active.
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with gesture behavior, force feel, or visual feedback.</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Build succeeds: `npx vite build`
3. All three gesture types produce distinct, visible particle effects
4. Gesture indicator correctly shows push/attract/concentrate/--
5. Hand aura appears at correct hand position with correct radius
6. 150ms stability prevents false triggers during transitions
7. 300ms decay on hand exit creates smooth force fadeout
8. Face occlusion freezes emotion state
9. Performance: 30+ FPS maintained with staggered inference
</verification>

<success_criteria>
- Push gesture creates explosive radial outward force
- Attract gesture creates spiral inward motion
- Pinch gesture creates vortex funnel concentration
- Gesture forces override emotion forces while active (user decision)
- Gesture indicator visible at top-left corner
- Hand aura shows force field radius
- 150ms stability timer prevents flicker (GES-06)
- 300ms decay on hand exit
- Occlusion handling freezes emotion when hand covers face
- 30+ FPS maintained throughout
</success_criteria>

<output>
After completion, create `.planning/phases/04-hand-gestures/04-03-SUMMARY.md`
</output>
