---
phase: 04-hand-gestures
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ml/GestureClassifier.ts
  - src/state/GestureState.ts
  - src/ui/GestureOverlay.ts
  - src/core/types.ts
  - src/core/constants.ts
  - src/style.css
autonomous: true

must_haves:
  truths:
    - "Open hand classifies as 'push', closed fist as 'attract', thumb-index pinch as 'pinch'"
    - "Gestures require ~150ms stability before activating (no flicker during transitions)"
    - "A visible gesture indicator shows the current detected gesture on screen"
    - "When hand leaves frame, gesture forces decay over ~300ms"
  artifacts:
    - path: "src/ml/GestureClassifier.ts"
      provides: "Rule-based gesture classification from hand landmarks"
      exports: ["classifyGesture", "getPalmCenter", "GestureType"]
    - path: "src/state/GestureState.ts"
      provides: "Gesture stability timer and decay state machine"
      exports: ["GestureState"]
    - path: "src/ui/GestureOverlay.ts"
      provides: "Gesture indicator UI overlay"
      exports: ["GestureOverlay"]
    - path: "src/core/types.ts"
      provides: "GestureType type export"
      contains: "GestureType"
    - path: "src/core/constants.ts"
      provides: "Gesture-related constants"
      contains: "GESTURE_STABILITY_MS"
  key_links:
    - from: "src/state/GestureState.ts"
      to: "src/ml/GestureClassifier.ts"
      via: "GestureType used as input to state machine"
      pattern: "GestureType"
    - from: "src/ui/GestureOverlay.ts"
      to: "src/core/types.ts"
      via: "GestureType for label mapping"
      pattern: "GestureType"
---

<objective>
Create gesture classification, stability state machine, and gesture overlay UI -- all the gesture pipeline components that don't touch the render loop or particle system.

Purpose: Build the complete gesture processing pipeline (classify -> stabilize -> display) as standalone modules ready for integration in Plan 04-03.
Output: GestureClassifier (rule-based), GestureState (stability + decay), GestureOverlay (UI indicator), plus types and constants.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-hand-gestures/04-CONTEXT.md
@.planning/phases/04-hand-gestures/04-RESEARCH.md

@src/core/types.ts
@src/core/constants.ts
@src/state/EmotionState.ts
@src/ui/EmotionOverlay.ts
@src/style.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gesture types and constants</name>
  <files>src/core/types.ts, src/core/constants.ts</files>
  <action>
**1. Add to `src/core/types.ts`:**

After the existing `BlendshapeWeight` interface, add:

```typescript
/** Gesture types detected from hand landmarks. */
export type GestureType = 'push' | 'attract' | 'pinch' | 'none';

/** Complete gesture state for a single frame. */
export interface GestureResult {
  gesture: GestureType;
  active: boolean;       // true when gesture is confirmed and force field should apply
  strength: number;      // 0-1, used for decay when hand leaves frame
  handPosition: { x: number; y: number } | null;  // scene coordinates, null if no hand
}
```

**2. Add to `src/core/constants.ts`:**

After the quality scaling constants at the end of the file, add a new section:

```typescript
// ── Gesture Detection ───────────────────────────────────────────────
/** Milliseconds a gesture must persist before activating (GES-06). */
export const GESTURE_STABILITY_MS = 150;

/** Milliseconds for gesture force to decay after hand leaves frame. */
export const GESTURE_DECAY_MS = 300;

/** Influence radius in pixels (converted to scene units dynamically). */
export const GESTURE_INFLUENCE_PX = 100;

/** Force field strengths (scene units/sec^2). Tunable. */
export const FORCE_PUSH_STRENGTH = 8.0;
export const FORCE_ATTRACT_STRENGTH = 4.0;
export const FORCE_PINCH_STRENGTH = 6.0;

/** Pinch detection: thumb-index distance threshold in normalized coords. */
export const PINCH_THRESHOLD = 0.06;
```
  </action>
  <verify>`npx tsc --noEmit` passes.</verify>
  <done>GestureType and GestureResult types exported from types.ts. All gesture constants centralized in constants.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create GestureClassifier and GestureState</name>
  <files>src/ml/GestureClassifier.ts, src/state/GestureState.ts</files>
  <action>
**1. Create `src/ml/GestureClassifier.ts`:**

Rule-based gesture classifier from 21 hand landmarks. No ML -- pure distance/position heuristics.

```typescript
import type { NormalizedLandmark } from '@mediapipe/tasks-vision';
import type { GestureType } from '../core/types.ts';
import { PINCH_THRESHOLD } from '../core/constants.ts';
```

Export function `classifyGesture(landmarks: NormalizedLandmark[]): GestureType`:
- Finger curl detection: compare TIP y to PIP y (MediaPipe y increases downward in normalized [0,1]):
  - `indexCurled = landmarks[8].y > landmarks[6].y` (TIP below PIP = curled)
  - `middleCurled = landmarks[12].y > landmarks[10].y`
  - `ringCurled = landmarks[16].y > landmarks[14].y`
  - `pinkyCurled = landmarks[20].y > landmarks[18].y`
- Pinch check (highest priority): `thumbIndexDist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y)`. If `< PINCH_THRESHOLD`, return `'pinch'`.
- Fist (attract): if ALL four fingers curled, return `'attract'`.
- Open hand (push): if NO fingers curled, return `'push'`.
- Otherwise: return `'none'`.

Export function `getPalmCenter(landmarks: NormalizedLandmark[]): { x: number; y: number }`:
- Midpoint of WRIST (index 0) and MIDDLE_FINGER_MCP (index 9).
- `return { x: (landmarks[0].x + landmarks[9].x) / 2, y: (landmarks[0].y + landmarks[9].y) / 2 }`

**2. Create `src/state/GestureState.ts`:**

State machine with 150ms stability timer and 300ms decay on hand loss.

```typescript
import type { GestureType, GestureResult } from '../core/types.ts';
import { GESTURE_STABILITY_MS, GESTURE_DECAY_MS } from '../core/constants.ts';
```

Class `GestureState` with:
- Private fields:
  - `currentGesture: GestureType = 'none'`
  - `pendingGesture: GestureType = 'none'`
  - `pendingTimer = 0` (ms accumulated)
  - `handPresent = false`
  - `decayTimer = 0` (ms accumulated)
  - `lastHandPosition: { x: number; y: number } | null = null`

- Method `update(rawGesture: GestureType, handDetected: boolean, handPosition: { x: number; y: number } | null, dt: number): GestureResult`:
  - If `handDetected`:
    - Set `handPresent = true`, `decayTimer = 0`
    - Store `lastHandPosition = handPosition`
    - Stability logic: if `rawGesture !== pendingGesture`, reset: `pendingGesture = rawGesture`, `pendingTimer = 0`. Else accumulate: `pendingTimer += dt * 1000`. If `pendingTimer >= GESTURE_STABILITY_MS`, set `currentGesture = pendingGesture`.
    - Return `{ gesture: currentGesture, active: currentGesture !== 'none', strength: 1, handPosition: lastHandPosition }`
  - If NOT `handDetected`:
    - If `handPresent` was true: set `handPresent = false`, `decayTimer = 0`.
    - Accumulate: `decayTimer += dt * 1000`
    - `decayProgress = Math.min(1, decayTimer / GESTURE_DECAY_MS)`
    - `strength = 1 - decayProgress`
    - If `decayProgress >= 1`: reset `currentGesture = 'none'`, `pendingGesture = 'none'`
    - Return `{ gesture: currentGesture, active: strength > 0, strength, handPosition: lastHandPosition }`

- Method `getCurrent(): GestureResult` -- returns last computed result (for frames where no new hand data arrives). Store last result in a private field updated by `update()`.

- Method `reset(): void` -- reset all fields to initial values.
  </action>
  <verify>`npx tsc --noEmit` passes. Both files compile with correct imports.</verify>
  <done>GestureClassifier correctly classifies open/fist/pinch from landmarks. GestureState implements 150ms stability timer and 300ms decay with clean state machine transitions.</done>
</task>

<task type="auto">
  <name>Task 3: Create GestureOverlay UI and CSS</name>
  <files>src/ui/GestureOverlay.ts, src/style.css</files>
  <action>
**1. Create `src/ui/GestureOverlay.ts`:**

Mirror the EmotionOverlay pattern: fixed position, pointer-events: none, minimal DOM writes.

```typescript
import type { GestureType } from '../core/types.ts';
```

Class `GestureOverlay` with:
- Private fields: `root: HTMLDivElement`, `label: HTMLSpanElement`, `prevGesture: GestureType | null = null`
- Constructor takes `container: HTMLElement`:
  - Create root div with class `gesture-overlay`
  - Create label span with class `gesture-overlay__label`, initial text `'--'`
  - Append label to root, root to container
- Method `update(gesture: GestureType): void`:
  - If `gesture === prevGesture`, return early (skip redundant DOM write)
  - Map gesture to display label: `push -> 'push'`, `attract -> 'attract'`, `pinch -> 'concentrate'`, `none -> '--'`
  - Set `label.textContent`, update `prevGesture`
  - Toggle visibility class: add `gesture-overlay--active` when gesture is not 'none', remove when 'none'
- Method `dispose(): void`: `this.root.remove()`

**2. Add CSS to `src/style.css`:**

After the existing `/* ===== Quality Indicator ===== */` section, add:

```css
/* ===== Gesture Overlay ===== */
.gesture-overlay {
  position: fixed;
  top: 60px;
  left: 16px;
  z-index: 50;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-radius: 12px;
  padding: 10px 14px;
  min-width: 90px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  color: rgba(255, 255, 255, 0.4);
  font-size: 13px;
  font-weight: 500;
  text-transform: capitalize;
  letter-spacing: 0.02em;
  pointer-events: none;
  transition: color 0.3s ease, opacity 0.3s ease;
  opacity: 0.6;
}

.gesture-overlay--active {
  color: #fff;
  opacity: 1;
}

.gesture-overlay__label {
  display: block;
  text-align: center;
}

/* ===== Hand Aura ===== */
.hand-aura {
  position: fixed;
  pointer-events: none;
  z-index: 2;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.15) 0%, transparent 70%);
  transform: translate(-50%, -50%);
  transition: opacity 0.15s ease;
  opacity: 0;
}

.hand-aura--visible {
  opacity: 1;
}
```

Place the gesture overlay at top-left (mirrors emotion overlay at top-right). The hand aura is a positioned div that will be placed over the hand position in Plan 04-03.
  </action>
  <verify>
1. `npx tsc --noEmit` passes.
2. `npx vite build` completes successfully.
  </verify>
  <done>GestureOverlay component created with CSS styling at top-left corner. Hand aura CSS prepared for Plan 04-03. Both the gesture overlay and emotion overlay can be visible simultaneously as separate UI elements.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Build succeeds: `npx vite build`
3. All 6 files created/modified as expected
4. GestureType is properly exported from types.ts and importable by all consumers
5. Constants are centralized in constants.ts (no magic numbers in classifier or state)
</verification>

<success_criteria>
- GestureClassifier classifies open/fist/pinch from hand landmarks using finger-curl + pinch-distance heuristics
- GestureState implements 150ms stability timer (GES-06) and 300ms decay on hand loss
- GestureOverlay displays current gesture label at top-left (mirroring EmotionOverlay pattern)
- All types and constants centralized in core/ files
- Hand aura CSS ready for positioning in Plan 04-03
- No TypeScript or build errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-hand-gestures/04-02-SUMMARY.md`
</output>
