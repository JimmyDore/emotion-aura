---
phase: 03-particle-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/particles/shaders/noise3d.glsl
  - src/particles/shaders/particle.vert.glsl
  - src/particles/shaders/particle.frag.glsl
  - src/particles/ParticlePool.ts
  - src/particles/ParticleSystem.ts
  - vite.config.ts
autonomous: true

must_haves:
  truths:
    - "Soft glowing particles render on screen with additive blending (ethereal, not basic dots)"
    - "Particles animate with organic simplex-noise-driven motion"
    - "Particle pool recycles particles via ring buffer without dynamic allocation"
  artifacts:
    - path: "src/particles/shaders/noise3d.glsl"
      provides: "Ashima/stegu 3D simplex noise (MIT licensed)"
      contains: "snoise"
    - path: "src/particles/shaders/particle.vert.glsl"
      provides: "Vertex shader with noise displacement and point sizing"
      contains: "gl_PointSize"
    - path: "src/particles/shaders/particle.frag.glsl"
      provides: "Fragment shader with soft radial glow falloff"
      contains: "gl_PointCoord"
    - path: "src/particles/ParticlePool.ts"
      provides: "Pre-allocated ring-buffer particle pool with spawn/update/recycle"
      exports: ["ParticlePool"]
    - path: "src/particles/ParticleSystem.ts"
      provides: "Three.js Points mesh with custom ShaderMaterial, init/update/dispose lifecycle"
      exports: ["ParticleSystem"]
  key_links:
    - from: "src/particles/ParticleSystem.ts"
      to: "src/particles/ParticlePool.ts"
      via: "ParticleSystem owns a ParticlePool and calls pool.update() each frame"
      pattern: "ParticlePool"
    - from: "src/particles/ParticleSystem.ts"
      to: "src/particles/shaders/particle.vert.glsl"
      via: "Imported as GLSL string via vite-plugin-glsl"
      pattern: "import.*particle\\.vert"
    - from: "src/particles/ParticleSystem.ts"
      to: "THREE.Points"
      via: "Creates Points mesh with custom ShaderMaterial added to provided scene"
      pattern: "new THREE\\.Points"
---

<objective>
Build the GPU particle rendering foundation: custom GLSL shaders for ethereal glowing particles, a pre-allocated ring-buffer particle pool, and the ParticleSystem class that creates a Three.js Points mesh with custom ShaderMaterial.

Purpose: This is the rendering core that all emotion-driven behavior and face-anchored spawning will be layered onto. Without organic-looking particles that animate fluidly, the entire phase fails visually.
Output: A working particle renderer that can spawn glowing, noise-displaced particles at arbitrary positions with configurable color/size/speed. Not yet wired to emotions or face position (that's Plan 03).
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-particle-system/03-RESEARCH.md
@src/scene/SceneManager.ts
@src/core/types.ts
@src/core/constants.ts
@vite.config.ts
@tsconfig.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install vite-plugin-glsl and create GLSL shaders</name>
  <files>
    vite.config.ts
    src/particles/shaders/noise3d.glsl
    src/particles/shaders/particle.vert.glsl
    src/particles/shaders/particle.frag.glsl
  </files>
  <action>
1. Install vite-plugin-glsl as a dev dependency: `npm install -D vite-plugin-glsl`

2. Update vite.config.ts to add the glsl plugin:
```ts
import glsl from 'vite-plugin-glsl';
// add glsl() to plugins array
```

3. Add a GLSL type declaration so TypeScript accepts `.glsl` imports. Create `src/glsl.d.ts`:
```ts
declare module '*.glsl' {
  const value: string;
  export default value;
}
```

4. Create `src/particles/shaders/noise3d.glsl` -- Ashima/stegu webgl-noise simplex 3D noise function (MIT licensed). Must export `float snoise(vec3 v)`. Use the standard implementation from https://github.com/ashima/webgl-noise (the `snoise` function with `mod289`, `permute`, `taylorInvSqrt` helpers). Do NOT hand-roll noise.

5. Create `src/particles/shaders/particle.vert.glsl`:
   - Uniforms: `float uTime`, `float uPixelRatio`, `vec2 uSpawnCenter`
   - Attributes: standard `position` (vec3), plus custom `float aSize`, `vec3 aColor`, `float aLife` (0-1 lifetime progress)
   - Varyings out: `vec3 vColor`, `float vLife`
   - Use `#include noise3d.glsl` (vite-plugin-glsl resolves #include)
   - Apply simplex noise displacement to position.xy: `displaced.x += snoise(vec3(position.xy * 0.5, uTime * 0.3)) * 0.05;` and similar for y with offset seed
   - Set `gl_PointSize = aSize * uPixelRatio * (300.0 / -mvPosition.z);` (scale by pixel ratio for HiDPI, 300.0 is a base scale factor for ortho camera at z=1)
   - Pass color and life to fragment shader via varyings

6. Create `src/particles/shaders/particle.frag.glsl`:
   - Varyings in: `vec3 vColor`, `float vLife`
   - Compute soft circular glow from `gl_PointCoord`: `vec2 center = gl_PointCoord - vec2(0.5); float dist = length(center);`
   - Discard if `dist > 0.5` (circular mask)
   - Glow formula: `float glow = exp(-dist * 6.0) * 0.8 + exp(-dist * 2.0) * 0.2;` (sharp core + soft halo)
   - Fade based on lifetime: `float fade = smoothstep(0.0, 0.15, vLife) * smoothstep(1.0, 0.85, vLife);` (fade in at birth, fade out at death)
   - Output: `gl_FragColor = vec4(vColor * glow, glow * fade);`
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should pass with no errors (glsl.d.ts covers .glsl imports).
    Run `npx vite build` -- should build successfully with vite-plugin-glsl resolving #include directives.
  </verify>
  <done>
    Three GLSL shader files exist with simplex noise, vertex displacement, and soft-glow fragment. vite-plugin-glsl installed and configured. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: ParticlePool ring buffer and ParticleSystem Three.js mesh</name>
  <files>
    src/particles/ParticlePool.ts
    src/particles/ParticleSystem.ts
  </files>
  <action>
1. Create `src/particles/ParticlePool.ts`:
   - Constructor takes `maxCount: number` (default 1500)
   - Pre-allocate Float32Arrays: `positions` (maxCount * 3), `velocities` (maxCount * 3), `colors` (maxCount * 3), `sizes` (maxCount), `lifetimes` (maxCount), `decayRates` (maxCount)
   - Track `activeCount: number` (how many particles are alive) and `cursor: number` (ring buffer write head)
   - `spawn(x, y, vx, vy, r, g, b, size, lifetime)`: Write particle data at cursor position. Increment cursor (wrap with modulo). Increment activeCount (cap at maxCount). Lifetime starts at 0, decayRate = 1/lifetime.
   - `update(dt: number)`: Loop over all active particles. For each: advance lifetime by `decayRate * dt`, add velocity to position, apply slight velocity damping (multiply by 0.995). If lifetime >= 1.0, mark dead by swapping with last active particle and decrementing activeCount. Return activeCount.
   - `getPositions()`, `getColors()`, `getSizes()`, `getLifetimes()`: Return the raw Float32Arrays (consumers set needsUpdate on BufferAttributes)
   - `getActiveCount()`: Return activeCount
   - `setMaxActive(n: number)`: Clamp activeCount for quality scaling (used by QualityScaler in Plan 03). Does NOT resize arrays -- just caps the active ceiling.

2. Create `src/particles/ParticleSystem.ts`:
   - Constructor takes `scene: THREE.Scene` and optional `maxParticles: number` (default 1500)
   - Create `ParticlePool(maxParticles)`
   - Create `THREE.BufferGeometry` with attributes:
     - `position`: Float32BufferAttribute from pool.getPositions(), itemSize 3
     - `aColor`: Float32BufferAttribute from pool.getColors(), itemSize 3
     - `aSize`: Float32BufferAttribute from pool.getSizes(), itemSize 1
     - `aLife`: Float32BufferAttribute from pool.getLifetimes(), itemSize 1
   - Set `geometry.setDrawRange(0, 0)` initially (no particles visible)
   - Create `THREE.ShaderMaterial` with:
     - vertexShader: import from particle.vert.glsl
     - fragmentShader: import from particle.frag.glsl
     - uniforms: `uTime: { value: 0 }`, `uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }`, `uSpawnCenter: { value: new THREE.Vector2(0, 0) }`
     - blending: THREE.AdditiveBlending
     - depthWrite: false
     - transparent: true
   - Create `THREE.Points(geometry, material)` and add to scene
   - `update(dt: number, time: number)`: Call pool.update(dt). Update drawRange to pool.getActiveCount(). Mark all buffer attributes as needsUpdate = true. Update uTime uniform.
   - `spawn(x, y, vx, vy, r, g, b, size, lifetime)`: Delegate to pool.spawn()
   - `setSpawnCenter(x, y)`: Update uSpawnCenter uniform
   - `getPool()`: Return pool reference (for QualityScaler in Plan 03)
   - `dispose()`: Remove Points from scene, dispose geometry and material
  </action>
  <verify>
    Run `npx tsc --noEmit` -- should compile cleanly.
    Run `npx vite build` -- should bundle successfully.
    Manually verify by temporarily adding to main.ts (then reverting):
    ```ts
    import { ParticleSystem } from './particles/ParticleSystem.ts';
    // after sceneManager init:
    const ps = new ParticleSystem(sceneManager.scene);
    // in animate: ps.spawn(0, 0, 0.01, 0.01, 1, 0.8, 0.3, 30, 2); ps.update(0.016, performance.now()/1000);
    ```
    Expect glowing orange-ish dots to appear and animate. Revert after verification.
  </verify>
  <done>
    ParticlePool manages a pre-allocated ring buffer of 1500 particles with spawn/update/recycle. ParticleSystem creates a THREE.Points mesh with custom ShaderMaterial using additive blending and the GLSL shaders. Both compile and can render visible glowing particles when wired to a scene.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npx vite build` succeeds
- src/particles/ directory contains 5 files: 3 shaders + ParticlePool.ts + ParticleSystem.ts
- GLSL #include directive resolves correctly (noise3d.glsl included in vertex shader)
- ParticleSystem can be instantiated with a THREE.Scene and spawn visible particles
</verification>

<success_criteria>
- Soft glowing particles render with additive blending (not basic dots)
- Simplex noise drives organic motion in the vertex shader
- Ring buffer pool manages particle lifecycle without dynamic allocation
- All TypeScript compiles cleanly with strict mode
- Build completes with vite-plugin-glsl resolving shader imports
</success_criteria>

<output>
After completion, create `.planning/phases/03-particle-system/03-01-SUMMARY.md`
</output>
