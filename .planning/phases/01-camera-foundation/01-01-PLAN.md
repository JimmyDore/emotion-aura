---
phase: 01-camera-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vite.config.ts
  - tsconfig.json
  - index.html
  - src/style.css
  - src/core/types.ts
  - src/core/constants.ts
  - src/scene/SceneManager.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "Dev server starts and serves a page with no errors"
    - "Three.js renders a transparent canvas overlay on top of a dark background"
    - "HMR works without leaking WebGL contexts"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "three"
    - path: "vite.config.ts"
      provides: "Vite dev server configuration"
      contains: "defineConfig"
    - path: "src/core/types.ts"
      provides: "Shared TypeScript interfaces for CameraError, LoadProgress, AppState"
      exports: ["CameraError", "LoadProgress", "AppState"]
    - path: "src/core/constants.ts"
      provides: "Configuration values: model URLs, camera constraints, thresholds"
      contains: "FACE_MODEL_URL"
    - path: "src/scene/SceneManager.ts"
      provides: "Three.js scene with transparent renderer, orthographic camera, resize handling, HMR cleanup"
      exports: ["SceneManager"]
    - path: "src/main.ts"
      provides: "Entry point skeleton that initializes SceneManager and starts render loop"
      contains: "requestAnimationFrame"
  key_links:
    - from: "src/main.ts"
      to: "src/scene/SceneManager.ts"
      via: "import and instantiation"
      pattern: "import.*SceneManager"
    - from: "src/scene/SceneManager.ts"
      to: "three"
      via: "Three.js WebGLRenderer with alpha: true"
      pattern: "alpha:\\s*true"
    - from: "src/main.ts"
      to: "import.meta.hot"
      via: "HMR dispose cleanup"
      pattern: "import\\.meta\\.hot"
---

<objective>
Create the Emotion Aura project scaffold with Vite 7 + TypeScript + Three.js, establish the core type system and configuration constants, and set up the Three.js transparent canvas overlay with a render loop and proper HMR cleanup.

Purpose: This is the foundation that all other plans in Phase 1 (and the entire project) build on. Every subsequent file imports from core/types.ts and core/constants.ts. The Three.js scene established here becomes the particle renderer in Phase 3.
Output: A working Vite dev server serving a page with a transparent Three.js canvas, stats.js FPS overlay, and the full project directory structure ready for webcam and UI work.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-camera-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Vite project with dependencies and core modules</name>
  <files>
    package.json
    vite.config.ts
    tsconfig.json
    index.html
    src/style.css
    src/core/types.ts
    src/core/constants.ts
  </files>
  <action>
    1. Create the Vite project from the working directory:
       ```
       npm create vite@latest emotion-aura -- --template vanilla-ts
       ```
       Then move all contents from the emotion-aura/ subdirectory up to the project root (/Users/jimmydore/Projets/computer_vision/) and remove the empty emotion-aura/ directory. This keeps the project root clean.

    2. Install dependencies:
       ```
       npm install three @mediapipe/tasks-vision
       npm install -D @types/three stats.js
       ```

    3. Create vite.config.ts:
       - Import defineConfig from 'vite'
       - Do NOT add COOP/COEP headers yet (per RESEARCH.md recommendation: start without, add only if MediaPipe throws SharedArrayBuffer errors)
       - Keep config minimal -- Vite works out of the box for vanilla-ts

    4. Update index.html:
       - Set title to "Emotion Aura"
       - Add a div#app container
       - Inside div#app: a video#webcam element (autoplay, playsinline, muted attributes) and a canvas#scene element
       - Link to src/main.ts as module script
       - Link to src/style.css

    5. Create src/style.css with:
       - CSS reset (margin: 0, padding: 0, overflow: hidden, background: #0a0a0f -- dark aesthetic)
       - html, body, #app at 100vw/100vh
       - #app as position: relative container
       - #webcam: position absolute, full size, object-fit: cover, transform: scaleX(-1) for mirror, z-index: 0, initially hidden (display: none)
       - #scene (canvas): position absolute, full size, z-index: 1, pointer-events: none
       - .screen class: position absolute, full size, z-index: 10, display flex center, dark semi-transparent background for UI overlay screens
       - Styles for progress bar, buttons, error messages (clean, dark aesthetic with subtle glow effects)
       - Use CSS custom properties for color palette: --color-primary (soft blue/cyan glow), --color-bg (dark), --color-text (light), --color-error (soft red), --color-success (soft green)

    6. Create src/core/types.ts with these interfaces:
       - CameraError: { type: 'denied' | 'not-found' | 'in-use' | 'overconstrained' | 'security' | 'unknown'; message: string; recoveryHint: string }
       - LoadProgress: { loaded: number; total: number; percent: number; label: string }
       - AppState: 'permission' | 'loading' | 'error' | 'live' | 'mobile-gate'

    7. Create src/core/constants.ts with:
       - FACE_MODEL_URL: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task'
       - HAND_MODEL_URL: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task'
       - WASM_CDN: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm' (pinned version, not @latest)
       - CAMERA_CONSTRAINTS: { video: { width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: 30, max: 30 }, facingMode: 'user' }, audio: false }
       - MAX_PIXEL_RATIO: 2
  </action>
  <verify>
    Run `npm run dev` and confirm the dev server starts without errors.
    Run `npx tsc --noEmit` and confirm no TypeScript compilation errors.
    Check that all files exist at their expected paths.
  </verify>
  <done>
    Vite dev server starts on localhost, TypeScript compiles cleanly, all core types and constants are defined and exported, index.html has the correct DOM structure with video and canvas elements, CSS provides the dark aesthetic foundation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Three.js scene setup with render loop and HMR cleanup</name>
  <files>
    src/scene/SceneManager.ts
    src/main.ts
  </files>
  <action>
    1. Create src/scene/SceneManager.ts as a class:
       - Constructor takes the canvas element (document.getElementById('scene'))
       - Creates WebGLRenderer with { canvas, antialias: true, alpha: true }
       - Sets clearColor to 0x000000 with opacity 0 (fully transparent)
       - Sets pixelRatio to Math.min(window.devicePixelRatio, MAX_PIXEL_RATIO) from constants
       - Sets size to window.innerWidth x window.innerHeight
       - Creates a THREE.Scene
       - Creates an OrthographicCamera: left=-aspect, right=aspect, top=1, bottom=-1, near=0.1, far=100, positioned at z=1
       - Adds a resize handler that updates camera aspect, projection matrix, and renderer size
       - Exposes a render() method that calls renderer.render(scene, camera)
       - Exposes a dispose() method that: calls renderer.dispose(), traverses scene to dispose all geometries and materials, removes resize listener
       - Exposes scene and camera as readonly properties (Phase 3 needs to add particles to scene)

    2. Create src/main.ts:
       - Import SceneManager
       - Import Stats from 'stats.js' (default import)
       - On DOMContentLoaded:
         a. Get canvas#scene element
         b. Instantiate SceneManager with the canvas
         c. Create Stats instance, position it top-left, append to document.body
         d. Create a render loop function using requestAnimationFrame:
            - stats.begin()
            - sceneManager.render()
            - stats.end()
            - requestAnimationFrame(loop)
         e. Start the loop
       - Add HMR cleanup:
         ```typescript
         if (import.meta.hot) {
           import.meta.hot.dispose(() => {
             sceneManager.dispose();
             stats.dom.remove();
             // Cancel animation frame if stored
           });
         }
         ```
       - Store the rAF ID so it can be cancelled in dispose

    Note: This main.ts is a skeleton. Plan 01-03 will refactor it to add the full 3-screen orchestration flow. For now, it just proves the Three.js scene works.
  </action>
  <verify>
    Run `npm run dev` and open the browser. Confirm:
    1. Page loads with dark background (no white flash)
    2. Stats.js FPS counter visible in top-left corner
    3. No console errors
    4. Run `npx tsc --noEmit` -- no TypeScript errors
    Edit a file and save -- confirm HMR triggers without errors and no duplicate canvases appear.
  </verify>
  <done>
    Three.js transparent renderer is running at 60fps on a dark background. Stats.js shows FPS overlay. HMR properly disposes old renderer and creates new one without leaking WebGL contexts. The SceneManager class is ready for Phase 3 particle additions.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. `npx tsc --noEmit` passes with no type errors
3. Browser shows dark page with stats.js FPS counter
4. No console errors in browser DevTools
5. Editing and saving a file triggers clean HMR (no duplicate elements)
6. All files exist at paths specified in the project structure
</verification>

<success_criteria>
- Dev server runs and serves the page
- TypeScript compiles cleanly
- Three.js renders transparent canvas over dark background
- Stats.js FPS overlay is visible
- HMR works without WebGL context leaks
- Core types (CameraError, LoadProgress, AppState) are defined and importable
- Constants (model URLs, camera constraints) are defined and importable
</success_criteria>

<output>
After completion, create `.planning/phases/01-camera-foundation/01-01-SUMMARY.md`
</output>
