---
phase: 01-camera-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/camera/CameraManager.ts
  - src/ml/ModelLoader.ts
  - src/ui/PermissionScreen.ts
  - src/ui/LoadingScreen.ts
  - src/ui/ErrorScreen.ts
autonomous: true

must_haves:
  truths:
    - "CameraManager requests webcam with correct constraints and returns a MediaStream"
    - "CameraManager throws typed CameraError objects for every failure mode (denied, not-found, in-use, overconstrained, security, unknown)"
    - "ModelLoader fetches MediaPipe model files with real byte-level progress tracking"
    - "PermissionScreen renders a pre-prompt explanation with Start Experience button"
    - "LoadingScreen renders a progress bar that updates as models download"
    - "ErrorScreen renders specific error messages with recovery hints based on CameraError type"
  artifacts:
    - path: "src/camera/CameraManager.ts"
      provides: "Webcam access with getUserMedia, stream lifecycle, typed error handling"
      exports: ["CameraManager"]
    - path: "src/ml/ModelLoader.ts"
      provides: "Fetch MediaPipe model files with ReadableStream progress tracking"
      exports: ["ModelLoader"]
    - path: "src/ui/PermissionScreen.ts"
      provides: "Pre-prompt explanation screen DOM creation and event handling"
      exports: ["PermissionScreen"]
    - path: "src/ui/LoadingScreen.ts"
      provides: "Model download progress bar UI"
      exports: ["LoadingScreen"]
    - path: "src/ui/ErrorScreen.ts"
      provides: "Camera error display with recovery guidance"
      exports: ["ErrorScreen"]
  key_links:
    - from: "src/camera/CameraManager.ts"
      to: "navigator.mediaDevices.getUserMedia"
      via: "Browser API call with CAMERA_CONSTRAINTS"
      pattern: "getUserMedia"
    - from: "src/camera/CameraManager.ts"
      to: "src/core/types.ts"
      via: "Throws CameraError interface"
      pattern: "CameraError"
    - from: "src/ml/ModelLoader.ts"
      to: "src/core/constants.ts"
      via: "Uses FACE_MODEL_URL, HAND_MODEL_URL"
      pattern: "FACE_MODEL_URL|HAND_MODEL_URL"
    - from: "src/ml/ModelLoader.ts"
      to: "src/core/types.ts"
      via: "Reports LoadProgress during download"
      pattern: "LoadProgress"
    - from: "src/ui/LoadingScreen.ts"
      to: "src/core/types.ts"
      via: "Accepts LoadProgress to update progress bar"
      pattern: "LoadProgress"
    - from: "src/ui/ErrorScreen.ts"
      to: "src/core/types.ts"
      via: "Accepts CameraError to show specific messages"
      pattern: "CameraError"
---

<objective>
Build the three core subsystems that Plan 01-03 will wire together: CameraManager for webcam access with full error handling, ModelLoader for MediaPipe model downloads with progress tracking, and the three UI screens (Permission, Loading, Error) for the user-facing flow.

Purpose: These are the building blocks of the three-screen startup flow. Each module is self-contained, typed, and testable in isolation. Plan 01-03 orchestrates them into the complete user experience.
Output: Five TypeScript modules -- CameraManager, ModelLoader, PermissionScreen, LoadingScreen, ErrorScreen -- all importing from core/types.ts and core/constants.ts.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-camera-foundation/01-RESEARCH.md
@.planning/phases/01-camera-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CameraManager and ModelLoader modules</name>
  <files>
    src/camera/CameraManager.ts
    src/ml/ModelLoader.ts
  </files>
  <action>
    1. Create src/camera/CameraManager.ts as a class:
       - Import CameraError from core/types.ts, CAMERA_CONSTRAINTS from core/constants.ts
       - Private property: stream (MediaStream | null)
       - Method: async requestAccess(): Promise&lt;MediaStream&gt;
         - Calls navigator.mediaDevices.getUserMedia(CAMERA_CONSTRAINTS)
         - On success: stores stream, returns it
         - On error: catches by error.name and throws typed CameraError objects:
           - NotAllowedError -> type: 'denied', message: "Camera access was denied", recoveryHint: "Click the camera icon in your browser's address bar to allow access, then refresh the page."
           - NotFoundError -> type: 'not-found', message: "No camera detected", recoveryHint: "Please connect a webcam and refresh the page."
           - NotReadableError -> type: 'in-use', message: "Camera is in use by another application", recoveryHint: "Close any other apps using your camera (video calls, screen recording), then try again."
           - OverconstrainedError -> type: 'overconstrained', message: "Camera doesn't support required settings", recoveryHint: "Try connecting a different camera."
           - SecurityError -> type: 'security', message: "Camera access requires a secure connection", recoveryHint: "Make sure you're accessing this page via HTTPS."
           - Default/unknown -> type: 'unknown', message: "An unexpected error occurred", recoveryHint: "Please refresh the page and try again."
       - Method: attachToVideo(videoElement: HTMLVideoElement): void
         - Sets videoElement.srcObject = this.stream
         - Returns a promise that resolves when video loadedmetadata fires
       - Method: stop(): void
         - If stream exists, calls stream.getTracks().forEach(track => track.stop())
         - Sets stream to null
       - Export the class as default and named export

    2. Create src/ml/ModelLoader.ts as a class:
       - Import LoadProgress from core/types.ts, FACE_MODEL_URL, HAND_MODEL_URL from core/constants.ts
       - Private properties: faceModelBuffer (Uint8Array | null), handModelBuffer (Uint8Array | null)
       - Private method: async fetchWithProgress(url: string, label: string, onProgress: (progress: LoadProgress) => void): Promise&lt;Uint8Array&gt;
         - Use the Fetch API with ReadableStream pattern from RESEARCH.md
         - Call fetch(url), check response.ok
         - Get Content-Length header for total bytes
         - Read chunks via response.body.getReader()
         - Accumulate chunks, call onProgress with { loaded, total, percent, label } on each chunk
         - Concatenate chunks into single Uint8Array and return
         - If Content-Length is missing, use estimated sizes (5MB for face, 4MB for hand) and cap percent at 95 until done
       - Method: async loadAll(onProgress: (progress: LoadProgress) => void): Promise&lt;void&gt;
         - Download face model first (it is needed in Phase 2 before hand model)
         - Then download hand model
         - Track combined progress: face model is 0-55%, hand model is 55-100% (weighted by approximate sizes)
         - Store buffers in instance properties
       - Getter: getFaceModelBuffer(): Uint8Array | null
       - Getter: getHandModelBuffer(): Uint8Array | null
       - Export the class as default and named export
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no TypeScript errors.
    Verify CameraManager imports CameraError and exports the class.
    Verify ModelLoader imports LoadProgress, FACE_MODEL_URL, HAND_MODEL_URL and exports the class.
    Verify all error types in CameraManager map to valid CameraError type literals.
  </verify>
  <done>
    CameraManager handles all 6 getUserMedia error types with specific CameraError messages. ModelLoader can fetch model files with byte-level progress tracking. Both modules compile cleanly and use shared types from core/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Permission, Loading, and Error UI screens</name>
  <files>
    src/ui/PermissionScreen.ts
    src/ui/LoadingScreen.ts
    src/ui/ErrorScreen.ts
  </files>
  <action>
    All three screens follow the same pattern: create DOM elements programmatically, append to a container, expose show()/hide() methods.

    1. Create src/ui/PermissionScreen.ts as a class:
       - Constructor takes container element (div#app)
       - Creates a div.screen.permission-screen with:
         - An icon/emoji area (camera icon -- use an SVG inline or a large emoji: a camera emoji is fine for now)
         - Heading: "Emotion Aura"
         - Description paragraph: "This experience uses your camera to detect your expressions and create a living particle aura around you."
         - Privacy note (smaller text): "Your video never leaves your device. Everything runs locally in your browser."
         - A large "Start Experience" button with class .btn-primary
       - Method: show(): void -- appends screen to container, makes visible
       - Method: hide(): void -- removes from DOM or sets display: none
       - Method: onStart(callback: () => void): void -- adds click listener to the button
       - The screen should have a subtle entrance animation (fade in, or slight scale up) using CSS transitions
       - Export class

    2. Create src/ui/LoadingScreen.ts as a class:
       - Constructor takes container element (div#app)
       - Creates a div.screen.loading-screen with:
         - Heading: "Loading AI Models..."
         - A progress bar container with an inner fill element (width controlled by percentage)
         - A percentage text (e.g., "67%")
         - A status label text that changes (e.g., "Downloading face detection model...")
       - Method: show(): void
       - Method: hide(): void -- smooth fade out transition before removing
       - Method: updateProgress(progress: LoadProgress): void
         - Updates the progress bar fill width to progress.percent + '%'
         - Updates the percentage text
         - Updates the label text to progress.label
       - The progress bar should have a smooth CSS transition on width (transition: width 0.3s ease)
       - Export class

    3. Create src/ui/ErrorScreen.ts as a class:
       - Import CameraError from core/types.ts
       - Constructor takes container element (div#app)
       - Creates a div.screen.error-screen with:
         - An error icon (warning triangle SVG or emoji)
         - Heading: "Something went wrong"
         - Error message paragraph (dynamic)
         - Recovery hint paragraph (dynamic, lighter color)
         - A "Try Again" button (class .btn-secondary) -- only shown for recoverable errors (in-use, unknown)
       - Method: show(error: CameraError): void
         - Populates the error message from error.message
         - Populates recovery hint from error.recoveryHint
         - Shows/hides "Try Again" based on error.type (show for 'in-use' and 'unknown', hide for 'denied', 'not-found', 'overconstrained', 'security')
         - Appends to container
       - Method: hide(): void
       - Method: onRetry(callback: () => void): void -- click listener on Try Again button
       - Export class

    IMPORTANT: All screen classes create DOM elements via document.createElement (not innerHTML with user data). Styles come from the CSS classes defined in Plan 01-01's style.css. If additional CSS classes are needed, add them to style.css.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- no TypeScript errors.
    Verify each screen class imports from core/types.ts where needed.
    Verify each screen class exports correctly.
    Verify PermissionScreen has onStart callback, LoadingScreen has updateProgress method accepting LoadProgress, ErrorScreen.show accepts CameraError.
  </verify>
  <done>
    Three UI screen classes exist, each with show/hide/update methods. PermissionScreen explains camera purpose and has Start button. LoadingScreen has progress bar that accepts LoadProgress updates. ErrorScreen shows specific messages and recovery hints based on CameraError type, with Try Again button for recoverable errors only. All compile cleanly with correct type imports.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. CameraManager handles all 6 getUserMedia error types
3. ModelLoader uses Fetch ReadableStream for progress (not XMLHttpRequest, not MediaPipe's modelAssetPath)
4. PermissionScreen includes privacy assurance text
5. LoadingScreen accepts LoadProgress and updates a real progress bar (not spinner)
6. ErrorScreen shows different messages for different CameraError types
7. All modules use shared types from core/types.ts (not inline type definitions)
</verification>

<success_criteria>
- All 5 files compile cleanly with strict TypeScript
- CameraManager.requestAccess() returns Promise&lt;MediaStream&gt; or throws CameraError
- ModelLoader.loadAll() downloads models with progress callbacks
- Each UI screen has show()/hide() lifecycle methods
- PermissionScreen has onStart callback for button click
- LoadingScreen.updateProgress accepts LoadProgress
- ErrorScreen.show accepts CameraError and shows appropriate message + recovery hint
</success_criteria>

<output>
After completion, create `.planning/phases/01-camera-foundation/01-02-SUMMARY.md`
</output>
