# Phase 6.1: Eye Wink Firework Particles - Research

**Researched:** 2026-02-08
**Domain:** Eye wink detection via MediaPipe blendshapes + firework particle burst spawning
**Confidence:** HIGH

## Summary

This phase adds a new interaction layer: detecting individual eye winks (one eye closed, other open) from the existing FaceLandmarker blendshapes and triggering spectacular firework particle bursts. The existing codebase already has all the infrastructure needed -- `FaceDetector` outputs blendshapes with `eyeBlinkLeft` and `eyeBlinkRight` scores (0.0-1.0), and `ParticleSystem` with its `ParticlePool` ring buffer supports spawning particles with arbitrary position, velocity, color, size, and lifetime.

The core technical challenge is threefold: (1) distinguishing intentional winks from natural blinks (both eyes close simultaneously during blinks), (2) designing the firework burst spawn pattern (radial velocity distribution from a screen-side origin point), and (3) integrating wink detection into the staggered inference loop without additional ML cost. All three are solvable with the existing stack -- no new libraries needed.

**Primary recommendation:** Build a `WinkDetector` class that reads `eyeBlinkLeft`/`eyeBlinkRight` from the existing blendshape categories, uses asymmetry + timing to distinguish winks from blinks, and a `FireworkSpawner` class that batch-spawns 80-150 particles in a radial burst pattern when triggered. Reuse the existing `ParticleSystem.spawn()` API -- no shader changes needed.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @mediapipe/tasks-vision | 0.10.32 (pinned) | FaceLandmarker with eyeBlinkLeft/eyeBlinkRight blendshapes | Already in project; provides 52 blendshapes including per-eye blink scores |
| Three.js | (existing) | ParticleSystem, Points mesh, ShaderMaterial | Already in project; additive blending + custom shaders handle firework glow |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| (none needed) | - | - | All capabilities exist in current codebase |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Blendshape-based wink detection | Eye Aspect Ratio (EAR) from landmarks | EAR requires geometric computation from raw landmarks; blendshapes are already computed by the model for free. Blendshapes are simpler and more reliable. |
| Reusing existing ParticlePool | Separate firework-only particle system | Separate system doubles GPU draw calls and adds complexity. The existing pool (MAX_PARTICLES=5000) has plenty of headroom for burst spawning alongside emotion particles. |
| CPU-side burst spawning | GPU-side (GPGPU/compute shader) fireworks | GPGPU adds massive complexity for a one-shot burst of ~100 particles. CPU spawn into existing ring buffer is trivial and performant. |

**Installation:**
```bash
# No new packages needed -- everything is already installed
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── ml/
│   ├── FaceDetector.ts          # (existing) outputs blendshapes
│   └── WinkDetector.ts          # NEW: reads eyeBlink* scores, detects winks
├── particles/
│   ├── ParticleSystem.ts        # (existing) spawn() API
│   ├── ParticlePool.ts          # (existing) ring buffer
│   └── FireworkSpawner.ts       # NEW: burst-spawns particles in radial pattern
├── state/
│   └── (no new state files)     # WinkDetector manages its own minimal state
├── core/
│   ├── types.ts                 # Add WinkEvent type
│   └── constants.ts             # Add wink detection + firework tuning constants
└── main.ts                      # Wire wink detection into face frame branch
```

### Pattern 1: Asymmetric Blink Detection (Wink vs Blink)

**What:** Distinguish intentional single-eye winks from natural bilateral blinks by comparing `eyeBlinkLeft` and `eyeBlinkRight` scores and applying a timing gate.

**When to use:** Every face inference frame (even frames in the staggered loop).

**Algorithm:**
```
For each face frame:
  leftScore  = blendshapeMap.get('eyeBlinkLeft')   // 0.0 = open, 1.0 = closed
  rightScore = blendshapeMap.get('eyeBlinkRight')

  // Asymmetry check: one eye must be closed while the other is open
  leftClosed  = leftScore  > WINK_CLOSE_THRESHOLD   (recommend 0.5)
  rightClosed = rightScore > WINK_CLOSE_THRESHOLD   (recommend 0.5)
  leftOpen    = leftScore  < WINK_OPEN_THRESHOLD    (recommend 0.3)
  rightOpen   = rightScore < WINK_OPEN_THRESHOLD    (recommend 0.3)

  // Wink = one closed AND other open (not both closed = blink)
  leftWink  = leftClosed  AND rightOpen
  rightWink = rightClosed AND leftOpen

  // Cooldown: prevent rapid re-triggering (500ms between fireworks)
  if (leftWink AND cooldownElapsed): trigger LEFT firework
  if (rightWink AND cooldownElapsed): trigger RIGHT firework
```

**Key insight:** The asymmetry gap between thresholds (0.5 for closed, 0.3 for open) prevents false positives during natural blinks where both eyes close nearly simultaneously. During a blink, both scores spike above 0.5 within 1-2 frames, so the "other eye open" check fails.

**Confidence:** HIGH -- the blendshape names and score ranges (0.0-1.0) are confirmed by Phase 2 research and the existing codebase. The asymmetry approach is well-established in eye-tracking literature.

### Pattern 2: Firework Radial Burst Spawn

**What:** Spawn 80-150 particles simultaneously in a radial pattern from a fixed screen position, with randomized velocities pointing outward from the burst center.

**When to use:** When a wink event is detected.

**Algorithm:**
```typescript
function spawnFirework(
  particleSystem: ParticleSystem,
  centerX: number,   // scene X coordinate (left side or right side)
  centerY: number,   // scene Y coordinate (center-ish)
  color: [number, number, number],  // primary color [r, g, b]
  count: number,     // 80-150 particles
): void {
  for (let i = 0; i < count; i++) {
    // Random angle for full 360-degree burst
    const angle = Math.random() * Math.PI * 2;
    // Random speed with variation (inner particles slower, outer faster)
    const speed = FIREWORK_MIN_SPEED + Math.random() * (FIREWORK_MAX_SPEED - FIREWORK_MIN_SPEED);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    // Color variation: jitter primary color for visual richness
    const r = color[0] + (Math.random() - 0.5) * 0.15;
    const g = color[1] + (Math.random() - 0.5) * 0.15;
    const b = color[2] + (Math.random() - 0.5) * 0.15;

    // Size: mix of small sparkles and larger glowing particles
    const size = FIREWORK_SIZE_MIN + Math.random() * (FIREWORK_SIZE_MAX - FIREWORK_SIZE_MIN);

    // Short lifetime: fireworks fade fast (0.8-2.0 seconds)
    const lifetime = FIREWORK_LIFETIME_MIN + Math.random() * (FIREWORK_LIFETIME_MAX - FIREWORK_LIFETIME_MIN);

    // Spawn at burst center with slight random offset for natural look
    const offsetX = (Math.random() - 0.5) * 0.05;
    const offsetY = (Math.random() - 0.5) * 0.05;

    particleSystem.spawn(
      centerX + offsetX, centerY + offsetY,
      vx, vy,
      Math.max(0, Math.min(1, r)),
      Math.max(0, Math.min(1, g)),
      Math.max(0, Math.min(1, b)),
      size, lifetime,
    );
  }
}
```

**Key insight:** The existing `ParticlePool.spawn()` appends to the active region and the existing shaders (additive blending, radial glow, lifetime fade) already produce visually spectacular results. Firework particles just need higher initial velocity and shorter lifetime than emotion particles.

### Pattern 3: Screen-Side Positioning

**What:** Map wink eye side to screen side for firework origin.

**When to use:** When calculating the burst center coordinates.

**Algorithm:**
```
Left eye wink  → RED firework on LEFT side of screen
Right eye wink → BLUE firework on RIGHT side of screen

Scene coordinates (orthographic camera):
  - Left side:  x = -aspect * 0.6, y = 0   (60% toward left edge)
  - Right side: x = +aspect * 0.6, y = 0   (60% toward right edge)

Note: The webcam is mirrored (scaleX(-1)), so MediaPipe "left" eye
appears on the right side of the user's screen. But the requirement says:
  "left eye closed = red firework on the LEFT side of the screen"
This means the firework appears on the same screen side as the eye label,
NOT the visual side. This needs careful mapping.
```

**Confidence:** MEDIUM -- The screen-side mapping needs careful attention due to the mirrored webcam. The requirement explicitly states "left eye closed = red firework on the LEFT side" which should be taken literally.

### Anti-Patterns to Avoid
- **Creating a separate Three.js Points mesh for fireworks:** The existing ParticleSystem handles up to 5000 particles. A burst of 100-150 is well within budget. A separate mesh doubles draw calls unnecessarily.
- **Using frame counting instead of time-based cooldown:** Frame rates vary (30-60fps). Always use elapsed time in seconds for cooldown gating.
- **Modifying the vertex/fragment shaders:** The existing neon spark shader with additive blending already produces spectacular firework-quality visuals. Firework particles are just emotion particles with different spawn parameters (faster, shorter-lived, radial).
- **Blocking the render loop during burst spawn:** Spawning 100-150 particles is trivial CPU work (~0.1ms). No need for batching or spreading across frames.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Particle rendering | Custom firework renderer | Existing `ParticleSystem.spawn()` | Same additive-blend shader produces great fireworks with different spawn params |
| Eye blink scores | Raw landmark geometry (EAR) | MediaPipe `eyeBlinkLeft`/`eyeBlinkRight` blendshapes | Model already computes these; accessing them is a Map lookup |
| Cooldown timing | Frame counter | `performance.now()` delta | Frame-rate-independent, same pattern as `GestureState` |
| Radial burst math | Complex physics engine | Simple `cos(angle)*speed`, `sin(angle)*speed` | Radial distribution is trigonometry, not physics simulation |

**Key insight:** This phase is pure integration work. Every building block already exists in the codebase. The only new code is the wink detection logic and the burst spawn configuration.

## Common Pitfalls

### Pitfall 1: Blinks Triggering Fireworks
**What goes wrong:** Natural blinks (both eyes close simultaneously) are misdetected as winks, causing constant firework spam.
**Why it happens:** Both `eyeBlinkLeft` and `eyeBlinkRight` spike above threshold during a normal blink, but with a 1-2 frame delay between them. If you only check one eye at a time, every blink triggers.
**How to avoid:** Always check BOTH eyes simultaneously: one must be above `WINK_CLOSE_THRESHOLD` AND the other must be below `WINK_OPEN_THRESHOLD`. The gap between these thresholds (0.5 vs 0.3) provides the hysteresis buffer.
**Warning signs:** Fireworks triggering every 3-4 seconds when user is just looking at screen normally.

### Pitfall 2: Fireworks During Strong Expressions
**What goes wrong:** Squinting during "angry" or "happy" expressions causes one eye to partially close, triggering unwanted fireworks.
**Why it happens:** `eyeSquintLeft`/`eyeSquintRight` can push `eyeBlinkLeft`/`eyeBlinkRight` scores above threshold during intense expressions.
**How to avoid:** Two strategies: (1) Set `WINK_CLOSE_THRESHOLD` high enough (0.5+) that squinting alone doesn't trigger it. (2) Optionally, suppress wink detection when emotion intensity is above a threshold (e.g., intensity > 0.7).
**Warning signs:** Fireworks triggering when user makes angry face or big smile.

### Pitfall 3: Particle Budget Exhaustion
**What goes wrong:** Rapid winking spawns hundreds of firework particles that fill the pool (MAX_PARTICLES=5000), crowding out emotion particles.
**Why it happens:** Each firework spawns 80-150 particles. Five rapid winks = 400-750 extra particles competing for pool space.
**How to avoid:** Enforce a cooldown period (500ms recommended) between firework triggers. Also, firework particles have short lifetimes (0.8-2.0s) compared to emotion particles (12s base * multiplier), so they drain quickly.
**Warning signs:** Emotion aura particles visibly thinning or disappearing after repeated winks.

### Pitfall 4: Staggered Inference Timing
**What goes wrong:** Wink detection runs on both face frames and hand frames, or runs on wrong frames.
**Why it happens:** The render loop staggeres face detection on even frames and hand detection on odd frames. Wink detection must run in the face frame branch.
**How to avoid:** Place wink detection inside the existing `if (!inferenceToggle)` block (face frame), right after blendshape processing. The blendshape `categories` array is already available there.
**Warning signs:** Wink detection working at half the expected rate, or running when no blendshapes are available.

### Pitfall 5: Mirrored Coordinate Confusion
**What goes wrong:** Left wink triggers firework on right side of screen, or vice versa.
**Why it happens:** Webcam is mirrored with `scaleX(-1)`. MediaPipe "left eye" refers to the anatomical left eye of the person, which appears on the right side of the mirrored video. The scene coordinate system also negates X.
**How to avoid:** Follow the requirement literally: "left eye closed = red firework on the LEFT side of the screen." Map `eyeBlinkLeft` (anatomical left) to screen LEFT regardless of mirror. In scene coordinates: left = negative X, right = positive X.
**Warning signs:** Firework appears on opposite side from what feels natural.

## Code Examples

Verified patterns from existing codebase:

### Reading Blendshape Scores (Existing Pattern)
```typescript
// Source: src/ml/EmotionClassifier.ts lines 31-35
// The blendshapeMap pattern is already established:
const blendshapeMap = new Map<string, number>();
for (const cat of categories) {
  blendshapeMap.set(cat.categoryName, cat.score);
}
const get = (name: string): number => blendshapeMap.get(name) ?? 0;

// For wink detection, simply:
const leftBlink = get('eyeBlinkLeft');   // 0.0 = open, 1.0 = closed
const rightBlink = get('eyeBlinkRight');
```

### Spawning Particles (Existing Pattern)
```typescript
// Source: src/main.ts lines 420-425
// The spawn API is already used for emotion particles:
particleSystem!.spawn(
  source.x + offsetX, source.y + offsetY,
  vx, vy,
  r, g, b,
  size, lifetime,
);

// Firework burst: same API, different parameters
// Higher velocity, shorter lifetime, radial angles
```

### Scene Coordinate System (Existing Pattern)
```typescript
// Source: src/particles/FaceLandmarkTracker.ts lines 127-131
// Orthographic camera: x = [-aspect, aspect], y = [-1, 1]
// Left side of screen:  x = -aspect * 0.6
// Right side of screen: x = +aspect * 0.6
const aspect = window.innerWidth / window.innerHeight;
```

### Cooldown Pattern (Existing Pattern)
```typescript
// Source: src/state/GestureState.ts
// The GestureState class uses time-based gating (stability timer + decay timer)
// WinkDetector can follow the same pattern:
// - Track lastTriggerTime per eye
// - Only trigger if (now - lastTriggerTime) > WINK_COOLDOWN_MS
```

### Integration Point in main.ts (Existing Pattern)
```typescript
// Source: src/main.ts lines 285-308
// Face frame branch (even frames):
if (!inferenceToggle) {
  const result = faceDetector!.detect(video!);
  if (result !== null) {
    if (result.faceBlendshapes && result.faceBlendshapes.length > 0) {
      const rawScores = emotionClassifier.classify(result.faceBlendshapes[0].categories);
      emotionState.update(rawScores);
      lastFaceLandmarks = result.faceLandmarks?.[0];

      // ← INSERT WINK DETECTION HERE
      // The categories array is: result.faceBlendshapes[0].categories
      // Pass to WinkDetector.update(categories, dt)
      // If wink detected, call FireworkSpawner.trigger(side, particleSystem, aspect)
    }
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| EAR (Eye Aspect Ratio) from landmarks | Blendshape scores from ML model | MediaPipe 0.10.x | No manual geometry calculation needed; model handles it |
| Separate particle systems per effect | Single shared pool with different spawn parameters | Common in game dev | Simpler architecture, shared GPU resources |
| GPU compute shader fireworks | CPU-spawn into shared Points buffer | Practical choice for <200 particles | Adequate for burst sizes; avoids GPGPU complexity |

**Deprecated/outdated:**
- Eye Aspect Ratio (EAR) calculation: Still works but unnecessary when blendshapes are already available. The blendshape model effectively does the EAR calculation internally.

## Open Questions

1. **Exact wink threshold values**
   - What we know: `eyeBlinkLeft`/`eyeBlinkRight` range 0.0-1.0. Literature suggests 0.5 for closed threshold.
   - What's unclear: The exact threshold that works best will depend on individual users and lighting. Need user testing.
   - Recommendation: Make thresholds configurable constants. Start with `WINK_CLOSE_THRESHOLD = 0.5` and `WINK_OPEN_THRESHOLD = 0.3`. Tune during testing.

2. **Firework particle count vs performance**
   - What we know: Pool capacity is 5000. Emotion particles at peak (surprised) spawn at 250/s with 12s lifetime = ~3000 active. A burst of 150 is ~3% of pool.
   - What's unclear: Whether rapid repeated winks could cause perceptible frame drops.
   - Recommendation: Start with 100 particles per burst. Add to `QualityScaler` awareness if needed, or rely on the existing cooldown (500ms) to rate-limit.

3. **Screen-side interpretation of "left" and "right"**
   - What we know: Requirement says "left eye closed = red firework on the LEFT side of the screen." MediaPipe `eyeBlinkLeft` = anatomical left eye.
   - What's unclear: Does the user expect "my left eye" (anatomical) or "left as I see it on screen" (mirrored)? The mirrored video makes anatomical left appear on screen right.
   - Recommendation: Follow the requirement text literally. `eyeBlinkLeft` -> left side of screen (negative scene X). The user specified screen sides explicitly.

## Sources

### Primary (HIGH confidence)
- Phase 2 Research (`02-RESEARCH.md`) -- Confirmed 52 blendshapes, `eyeBlinkLeft` at position in eye region (14 blendshapes), values 0.0-1.0
- Existing codebase (`src/ml/EmotionClassifier.ts`) -- Verified blendshapeMap pattern with `categoryName` lookup
- Existing codebase (`src/particles/ParticleSystem.ts`, `ParticlePool.ts`) -- Verified spawn API, ring buffer, MAX_PARTICLES=5000
- Existing codebase (`src/main.ts`) -- Verified staggered inference loop, face frame branch at lines 285-308
- MediaPipe official docs (https://ai.google.dev/edge/mediapipe/solutions/vision/face_landmarker) -- FaceLandmarker outputs 52 blendshapes

### Secondary (MEDIUM confidence)
- Dev.to blink detection article (https://dev.to/piko/i-built-an-ai-that-reads-my-blinks-and-speaks-morse-code-heres-the-code-18df) -- Confirmed score near 0 = open, near 1 = closed
- Springer research on blink vs wink (https://link.springer.com/article/10.1007/s11042-018-6554-8) -- Asymmetry + timing approach for distinguishing winks from blinks

### Tertiary (LOW confidence)
- Three.js firework showcases (discourse.threejs.org) -- Confirmed radial burst + additive blending approach but no specific code verified

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- No new libraries, everything exists in codebase
- Architecture: HIGH -- Clear integration points identified, follows existing patterns
- Pitfalls: HIGH -- Well-known problems in blink/wink detection literature, mitigations clear
- Wink thresholds: MEDIUM -- Values are reasonable starting points but need user testing
- Screen-side mapping: MEDIUM -- Requirement text is explicit but mirror semantics add ambiguity

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable -- no moving dependencies)
