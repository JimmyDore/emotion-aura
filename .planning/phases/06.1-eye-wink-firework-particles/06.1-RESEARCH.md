# Phase 6.1: Eye Wink Firework Particles - Research

**Researched:** 2026-02-08
**Domain:** Eye wink/blink detection via MediaPipe blendshapes + firework particle burst spawning
**Confidence:** HIGH

## Summary

This phase adds a new interaction layer: detecting individual eye winks (and blinks) from the existing FaceLandmarker blendshapes and triggering spectacular firework particle bursts. The existing codebase already has all the infrastructure needed -- `FaceDetector` outputs blendshapes with `eyeBlinkLeft` (index 9) and `eyeBlinkRight` (index 10) scores ranging 0.0-1.0, and `ParticleSystem` with its `ParticlePool` ring buffer supports spawning particles with arbitrary position, velocity, color, size, and lifetime.

The core technical work is: (1) detecting eye closure events using a 0.5 threshold on `eyeBlinkLeft`/`eyeBlinkRight` blendshapes, (2) spawning 150 particles in a radial burst from a fixed screen-side origin point, and (3) handling blinks as a FEATURE -- both eyes closed triggers DOUBLE fireworks on BOTH sides simultaneously. No new dependencies are needed. All building blocks exist in the codebase.

Per CONTEXT.md decisions: LEFT wink = GOLD fireworks on left screen side, RIGHT wink = CYAN fireworks on right screen side. Blinks (both eyes closed) = simultaneous GOLD left + CYAN right. 150 particles per burst, 5.0-8.0 second lifetime (long linger), weightless radial expansion (no gravity), single point origin, 250ms rapid-fire cooldown, 80% toward screen edge positioning.

**Primary recommendation:** Build a `WinkDetector` class that reads `eyeBlinkLeft`/`eyeBlinkRight` from the existing blendshape categories with a 0.5 threshold, emits wink/blink events with a 250ms cooldown, and a `FireworkSpawner` function that batch-spawns 150 particles in a radial burst pattern. Reuse the existing `ParticleSystem.spawn()` API -- no shader changes needed.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @mediapipe/tasks-vision | 0.10.32 (pinned) | FaceLandmarker with `eyeBlinkLeft`/`eyeBlinkRight` blendshapes (indices 9, 10) | Already in project; provides 52 blendshapes including per-eye blink scores 0.0-1.0 |
| Three.js | 0.182.0 | ParticleSystem, Points mesh with additive blending ShaderMaterial | Already in project; custom neon-spark shaders handle firework glow perfectly |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| (none needed) | - | - | All capabilities exist in current codebase |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Blendshape-based wink detection | Eye Aspect Ratio (EAR) from raw landmarks | EAR requires geometric computation; blendshapes are already computed by the model. Blendshapes are simpler and more reliable |
| Shared ParticlePool | Separate firework-only particle system | Separate system doubles GPU draw calls. The shared pool (MAX_PARTICLES=5000) has ample headroom. Plus, shared pool means hand gestures (push/attract) automatically affect firework particles too |
| CPU burst spawning | GPU compute shader fireworks | GPGPU adds massive complexity for a 150-particle burst. CPU spawn into the existing ring buffer is trivial (~0.1ms) |

**Installation:**
```bash
# No new packages needed -- everything is already installed
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── ml/
│   ├── FaceDetector.ts          # (existing) outputs blendshapes
│   └── WinkDetector.ts          # NEW: reads eyeBlink* scores, detects winks/blinks
├── particles/
│   ├── ParticleSystem.ts        # (existing) spawn() API
│   ├── ParticlePool.ts          # (existing) ring buffer, shared by emotion + firework
│   └── FireworkSpawner.ts       # NEW: burst-spawns 150 particles in radial pattern
├── core/
│   ├── types.ts                 # Add WinkEvent type
│   └── constants.ts             # Add wink + firework tuning constants
└── main.ts                      # Wire wink detection into face frame branch
```

### Pattern 1: Wink/Blink Detection with Single Threshold

**What:** Detect eye closure events using a single 0.5 threshold on `eyeBlinkLeft`/`eyeBlinkRight` blendshape scores. Distinguish winks from blinks, but treat BOTH as valid triggers (blinks are a feature, not noise).

**When to use:** Every face inference frame (even frames in the staggered loop).

**Algorithm:**
```
For each face frame:
  leftScore  = blendshapeMap.get('eyeBlinkLeft')   // 0.0 = open, 1.0 = closed
  rightScore = blendshapeMap.get('eyeBlinkRight')

  leftClosed  = leftScore  >= WINK_THRESHOLD   (0.5)
  rightClosed = rightScore >= WINK_THRESHOLD    (0.5)

  if leftClosed AND rightClosed:
    // BLINK = DOUBLE firework (gold left + cyan right)
    if cooldownElapsed(left): triggerFirework(LEFT, GOLD)
    if cooldownElapsed(right): triggerFirework(RIGHT, CYAN)

  else if leftClosed AND NOT rightClosed:
    // LEFT WINK = gold firework on left side
    if cooldownElapsed(left): triggerFirework(LEFT, GOLD)

  else if rightClosed AND NOT leftClosed:
    // RIGHT WINK = cyan firework on right side
    if cooldownElapsed(right): triggerFirework(RIGHT, CYAN)
```

**Key insight:** Unlike typical wink detection that tries to FILTER blinks, this design EMBRACES blinks as double-firework triggers. The 0.5 threshold requires a deliberate closure (not just squinting). Each side has its own independent cooldown timer, so a blink triggers both sides independently.

**Confidence:** HIGH -- `eyeBlinkLeft`/`eyeBlinkRight` blendshape names and 0.0-1.0 score range confirmed from MediaPipe source code at `google-ai-edge/mediapipe` (face_blendshapes_graph.cc). The 0.5 threshold is the user's explicit choice from CONTEXT.md.

### Pattern 2: Firework Radial Burst Spawn

**What:** Spawn exactly 150 particles simultaneously in a full 360-degree radial pattern from a fixed screen-side origin point, with randomized outward velocities. No gravity -- particles expand weightlessly in all directions.

**When to use:** When a wink or blink event fires (after cooldown check).

**Algorithm:**
```typescript
function spawnFirework(
  particleSystem: ParticleSystem,
  centerX: number,        // scene X: -0.8*aspect (left) or +0.8*aspect (right)
  centerY: number,        // scene Y: 0 (vertical center)
  baseColor: [r, g, b],   // GOLD [1.0, 0.84, 0.0] or CYAN [0.0, 0.9, 1.0]
  count: number,          // 150
): void {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = FIREWORK_SPEED_MIN + Math.random() * (FIREWORK_SPEED_MAX - FIREWORK_SPEED_MIN);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    // Color jitter for visual richness
    const r = clamp(baseColor[0] + (Math.random() - 0.5) * COLOR_JITTER * 2);
    const g = clamp(baseColor[1] + (Math.random() - 0.5) * COLOR_JITTER * 2);
    const b = clamp(baseColor[2] + (Math.random() - 0.5) * COLOR_JITTER * 2);

    const size = FIREWORK_SIZE_MIN + Math.random() * (FIREWORK_SIZE_MAX - FIREWORK_SIZE_MIN);
    const lifetime = FIREWORK_LIFETIME_MIN + Math.random() * (FIREWORK_LIFETIME_MAX - FIREWORK_LIFETIME_MIN);

    // Tiny offset from origin (single point, not diffuse)
    const ox = (Math.random() - 0.5) * FIREWORK_ORIGIN_JITTER * 2;
    const oy = (Math.random() - 0.5) * FIREWORK_ORIGIN_JITTER * 2;

    particleSystem.spawn(centerX + ox, centerY + oy, vx, vy, r, g, b, size, lifetime);
  }
}
```

**Confidence:** HIGH -- The existing `ParticlePool.spawn()` API (verified in `src/particles/ParticlePool.ts`) accepts exactly these parameters. The pool's 0.995 per-frame velocity damping provides natural deceleration. The existing shader's additive blending + radial glow + lifetime fade produces spectacular firework visuals with zero shader changes.

### Pattern 3: Screen-Side Positioning (Mirrored)

**What:** Map wink eye side to the correct screen side in mirrored coordinates.

**Coordinate system:**
```
Orthographic camera: x = [-aspect, aspect], y = [-1, 1]
Webcam mirrored via scaleX(-1) AND scene x negation in FaceLandmarkTracker

Result: User's LEFT eye (eyeBlinkLeft) appears on LEFT side of screen
        User's RIGHT eye (eyeBlinkRight) appears on RIGHT side of screen

Firework origins (80% toward screen edge, vertical center):
  LEFT firework:  x = -0.8 * aspect, y = 0   (GOLD)
  RIGHT firework: x = +0.8 * aspect, y = 0   (CYAN)
```

**Key insight:** The mirrored webcam makes it intuitive -- the user sees their left eye on the left side of screen. The firework appears on the same side as the eye they closed. MediaPipe's `eyeBlinkLeft` refers to the subject's anatomical left eye, which in the mirrored view appears on screen left. So `eyeBlinkLeft` -> screen left is the correct and intuitive mapping.

**Confidence:** HIGH -- Verified through `src/particles/FaceLandmarkTracker.ts` line 128: `x: -(lm.x * 2 - 1) * aspect * coverScaleX` negates x for mirror. A landmark on the subject's left side (high MediaPipe x) maps to negative scene x (screen left).

### Pattern 4: Independent Per-Side Cooldown

**What:** Each side (left/right) has its own cooldown timer. A blink can trigger both sides in one frame because each side checks independently.

**Why independent:** With a 250ms cooldown and blinks triggering BOTH sides, shared cooldown would mean a blink resets the timer for both, blocking the next wink for 250ms regardless of which eye. Independent timers allow: wink left (gold) -> 100ms later -> wink right (cyan) -> both fire because each had independent 250ms elapsed.

**Implementation:**
```typescript
class WinkDetector {
  private lastLeftTrigger = 0;
  private lastRightTrigger = 0;

  update(categories: Category[], now: number): WinkEvent | null {
    // ... check thresholds ...
    // leftCooldownOk = (now - this.lastLeftTrigger) >= WINK_COOLDOWN_MS
    // rightCooldownOk = (now - this.lastRightTrigger) >= WINK_COOLDOWN_MS
  }
}
```

**Confidence:** HIGH -- Follows the same time-based gating pattern used in `GestureState` (verified in `src/state/GestureState.ts`).

### Anti-Patterns to Avoid
- **Creating a separate Three.js Points mesh for fireworks:** The existing `ParticleSystem` handles up to 5000 particles. A burst of 150 is 3% of budget. A separate mesh doubles GPU draw calls unnecessarily, and more importantly, hand gesture force fields would NOT affect firework particles if they were in a separate system.
- **Using frame counting instead of time-based cooldown:** Frame rates vary (30-60fps). Always use `performance.now()` in milliseconds for cooldown gating.
- **Modifying the vertex/fragment shaders:** The existing neon spark shader with additive blending, radial glow core+halo+outer, and lifetime fade already produces spectacular firework-quality visuals. Firework particles are just particles with different spawn parameters.
- **Filtering out blinks:** The user explicitly wants blinks to trigger DOUBLE fireworks. Do NOT add asymmetry checks to reject simultaneous eye closure.
- **Adding gravity to firework particles:** The user chose weightless radial expansion. The pool's velocity update already has no gravity term -- it just applies velocity + damping. This is already correct for the desired effect.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Particle rendering | Custom firework renderer | Existing `ParticleSystem.spawn()` + shared `ParticlePool` | Same additive-blend shader produces great fireworks; shared pool means gesture interactions work automatically |
| Eye blink scores | Raw landmark EAR geometry | MediaPipe `eyeBlinkLeft`/`eyeBlinkRight` blendshapes | Model already computes these; accessing them is a Map lookup on `categoryName` |
| Velocity damping | Custom deceleration per particle type | Existing pool-wide `0.995` per-frame damping | All particles already decelerate naturally; firework particles benefit from this too |
| Cooldown timing | Frame counter or setTimeout | `performance.now()` delta comparison | Frame-rate-independent, same pattern as `GestureState` |
| Radial burst math | Complex physics or library | `cos(angle)*speed`, `sin(angle)*speed` | Full 360-degree radial distribution is basic trigonometry |

**Key insight:** This phase is pure integration work. Every building block exists in the codebase. The only new code is (1) a WinkDetector class (~60 lines) that reads two blendshape scores and manages cooldowns, and (2) a FireworkSpawner function (~30 lines) that calls the existing `spawn()` API in a loop with radial parameters.

## Common Pitfalls

### Pitfall 1: Expression Squinting Triggers False Winks
**What goes wrong:** Squinting during "angry" or "happy" expressions causes one eye to partially close above the 0.5 threshold, triggering unwanted fireworks.
**Why it happens:** `eyeSquintLeft`/`eyeSquintRight` can contribute to `eyeBlinkLeft`/`eyeBlinkRight` scores during intense expressions, pushing them above 0.5.
**How to avoid:** The 0.5 threshold is designed to require a deliberate closure, not a squint. In testing, if false positives occur, raise threshold to 0.6. The 250ms cooldown also limits damage from occasional false triggers.
**Warning signs:** Fireworks triggering when user makes angry face or big smile without intentionally closing an eye.

### Pitfall 2: Particle Budget Exhaustion During Rapid Winking
**What goes wrong:** Rapid winking spawns many firework particles that fill the pool (MAX_PARTICLES=5000), crowding out emotion aura particles.
**Why it happens:** At 250ms cooldown, a user can fire 4 bursts/second. At 150 particles each = 600 particles/second from fireworks alone. With 5-8 second lifetimes, sustained rapid winking could accumulate 3000-4800 firework particles.
**How to avoid:** The pool's ring-buffer design handles this gracefully -- when full, new spawns are silently dropped (line 69: `if (this.activeCount >= this.maxActive) return`). The QualityScaler also dynamically reduces maxActive if FPS drops. Additionally, the existing damping (0.995/frame) makes particles nearly stationary after ~5 seconds, so they're visually unobtrusive even at high counts. The real mitigation: the user WANTS "firework machine gun" -- this is a desired feature, not a bug.
**Warning signs:** Emotion aura visibly thinning (pool saturated). If this occurs, consider reducing firework count to 120 or reducing max lifetime to 4.0s.

### Pitfall 3: Staggered Inference Placement
**What goes wrong:** Wink detection runs in the wrong branch of the staggered inference loop, or runs on frames where no blendshapes are available.
**Why it happens:** The render loop alternates face detection (even frames) and hand detection (odd frames). Blendshapes only arrive on face frames.
**How to avoid:** Place wink detection inside the existing `if (!inferenceToggle)` block in `main.ts` (line 285), right after `emotionClassifier.classify()` which already processes `result.faceBlendshapes[0].categories`. Pass the same `categories` array to `WinkDetector.update()`.
**Warning signs:** Wink detection not responding, or only working half the time.

### Pitfall 4: Aspect Ratio in Firework Origin
**What goes wrong:** Firework appears at wrong x position on non-16:9 screens or after window resize.
**Why it happens:** The firework origin is calculated as `+/- 0.8 * aspect`, but `aspect` must be the live viewport aspect ratio, not a stored value.
**How to avoid:** Compute `aspect = window.innerWidth / window.innerHeight` at trigger time (it's already computed every frame in the animate loop at line 268). Pass it to the firework spawner.
**Warning signs:** Firework appearing too close to center or off-screen edge on ultra-wide or portrait monitors.

### Pitfall 5: Color Clamping
**What goes wrong:** RGB values exceed 0-1 range after jitter, causing visual artifacts.
**Why it happens:** Adding random jitter to a color near 1.0 (e.g., gold's red channel = 1.0) can push it above 1.0.
**How to avoid:** Clamp all jittered color values to [0, 1] before passing to `spawn()`. Use `Math.max(0, Math.min(1, value))`.
**Warning signs:** Colors appearing as unexpected white or oversaturated (though additive blending is somewhat forgiving of values > 1.0).

## Code Examples

Verified patterns from existing codebase:

### Reading Blendshape Scores (Existing Pattern)
```typescript
// Source: src/ml/EmotionClassifier.ts lines 31-35
// Build lookup map for O(1) access by categoryName:
const blendshapeMap = new Map<string, number>();
for (const cat of categories) {
  blendshapeMap.set(cat.categoryName, cat.score);
}
const get = (name: string): number => blendshapeMap.get(name) ?? 0;

// For wink detection:
const leftBlink = get('eyeBlinkLeft');   // 0.0 = open, 1.0 = closed
const rightBlink = get('eyeBlinkRight'); // 0.0 = open, 1.0 = closed
```

### Spawning into Shared Pool (Existing Pattern)
```typescript
// Source: src/main.ts lines 420-425
// The existing spawn API used for emotion particles:
particleSystem!.spawn(
  source.x + offsetX, source.y + offsetY,
  vx, vy,
  r, g, b,
  size, lifetime,
);
// Firework burst uses the SAME API in a loop with radial velocities
```

### Force Field Auto-Integration (Existing Pattern)
```typescript
// Source: src/main.ts lines 439-452
// Gesture force fields iterate ALL active particles in the pool:
particleSystem!.getPool().applyForceField(
  result.handPosition.x, result.handPosition.y,
  result.gesture, influenceRadius, effectiveStrength, dt,
);
// Because firework particles live in the SAME pool,
// hand gestures (push/attract) automatically affect them.
// This is the KEY reason to use the shared pool.
```

### Integration Point in main.ts
```typescript
// Source: src/main.ts lines 285-293
// Face frame branch (even frames):
if (!inferenceToggle) {
  const result = faceDetector!.detect(video!);
  if (result !== null) {
    if (result.faceBlendshapes && result.faceBlendshapes.length > 0) {
      const rawScores = emotionClassifier.classify(result.faceBlendshapes[0].categories);
      emotionState.update(rawScores);
      lastFaceLandmarks = result.faceLandmarks?.[0];

      // INSERT WINK DETECTION HERE:
      // const winkEvents = winkDetector.update(
      //   result.faceBlendshapes[0].categories,
      //   performance.now(),
      // );
      // for (const event of winkEvents) {
      //   spawnFirework(particleSystem!, event.side, aspect);
      // }
    }
  }
}
```

## Claude's Discretion Recommendations

Parameters the user left to Claude's judgment, with research-backed recommendations:

### Radial Velocity Range
**Recommendation:** `FIREWORK_SPEED_MIN = 0.3`, `FIREWORK_SPEED_MAX = 0.8` (scene units/sec)
**Rationale:** The orthographic scene spans approximately [-1.78, 1.78] on x-axis for 16:9 aspect. With the pool's built-in velocity damping (0.995/frame at 60fps, which halves velocity every ~9.2 seconds), particles starting at 0.3-0.8 units/sec will travel approximately 0.5-1.3 scene units total before becoming nearly stationary. This creates a visible radial expansion that fills a significant portion of the screen half without flying completely off-screen. The random range within [0.3, 0.8] creates inner/outer particle layers -- faster particles form the outer shell, slower ones form the dense glowing core.

### Particle Size Range
**Recommendation:** `FIREWORK_SIZE_MIN = 15`, `FIREWORK_SIZE_MAX = 45` (pixels, before pixel ratio scaling)
**Rationale:** The existing `PARTICLE_SIZE_BASE` is 35px. For fireworks, a wider range (15-45px) creates visual depth: small sparkles (15px) act as spray/debris, while large particles (45px) are the glowing burst heads. The existing shader's multi-layer glow (core + halo + outer) means even 15px particles have visible halos, so small does not mean invisible. The `effectiveParticleSize` capping based on `gl_PointSize` hardware limit (checked at line 188-193 of main.ts) should also be applied to firework sizes.

### Color Jitter Amount
**Recommendation:** `FIREWORK_COLOR_JITTER = 0.08` (per RGB channel, +/-)
**Rationale:** For GOLD base [1.0, 0.84, 0.0], jitter of +/-0.08 creates warm variations from amber to pale gold without straying into orange or green. For CYAN base [0.0, 0.9, 1.0], it creates variations from teal to electric blue. The jitter is per-channel per-particle, so a 150-particle burst produces a rich spectrum of nearby hues that reads as a single cohesive color explosion with depth. Lower values (0.05) feel monotone; higher values (0.15) lose color identity.

### Position Offset (Origin Jitter)
**Recommendation:** `FIREWORK_ORIGIN_JITTER = 0.02` (scene units, +/-)
**Rationale:** The user chose "single point origin" explicitly, so this should be minimal. A +/-0.02 offset (about 1% of screen width) prevents exact particle overlap at the origin point (which causes z-fighting artifacts even with additive blending) while being visually imperceptible as a spread. All 150 particles will appear to explode from one tight spot.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| EAR (Eye Aspect Ratio) from raw landmarks | Blendshape scores from ML model | MediaPipe 0.10.x (2023) | No manual geometry; model handles it. `eyeBlinkLeft`/`eyeBlinkRight` are direct outputs |
| Separate particle systems per effect | Single shared pool with different spawn parameters | Common game dev pattern | Simpler architecture, shared GPU resources, automatic cross-effect interactions |
| Blink = noise to filter | Blink = feature (double trigger) | User decision (CONTEXT.md) | Simplifies detection logic (no asymmetry filtering needed) |

**Deprecated/outdated:**
- Eye Aspect Ratio (EAR) calculation: Still works but unnecessary when blendshapes are already available. The blendshape model effectively computes EAR internally.

## Open Questions

1. **Threshold tuning after implementation**
   - What we know: User chose 0.5 threshold. MediaPipe scores range 0.0-1.0 with 1.0 = fully closed.
   - What's unclear: Whether 0.5 will feel too sensitive or too hard to trigger for different users and lighting conditions.
   - Recommendation: Define as a constant `WINK_THRESHOLD = 0.5` in `constants.ts`. If testing reveals issues, it's a single-line change. The 250ms cooldown provides a safety net against accidental triggers.

2. **Pool saturation under sustained rapid winking**
   - What we know: Worst case at 250ms cooldown: 4 bursts/sec * 150 particles * 6.5s avg lifetime = ~3900 active firework particles. Pool total is 5000. Emotion particles at peak surprised = ~3000 active.
   - What's unclear: Whether the QualityScaler responds fast enough when emotion+firework particles together approach 5000.
   - Recommendation: This is an edge case that only arises during sustained rapid winking during surprised emotion. The pool silently drops spawns when full. The QualityScaler will kick in if FPS drops. No pre-emptive action needed, but monitor during testing.

## Sources

### Primary (HIGH confidence)
- [MediaPipe source code: face_blendshapes_graph.cc](https://github.com/google-ai-edge/mediapipe/blob/master/mediapipe/tasks/cc/vision/face_landmarker/face_blendshapes_graph.cc) -- Complete list of all 52 blendshape names. `eyeBlinkLeft` at index 9, `eyeBlinkRight` at index 10. Scores 0.0-1.0.
- [MediaPipe FaceLandmarker official docs](https://ai.google.dev/edge/mediapipe/solutions/vision/face_landmarker) -- FaceLandmarker outputs 52 blendshapes, confirmed `outputFaceBlendshapes: true` configuration.
- Existing codebase `src/ml/EmotionClassifier.ts` -- Verified `categoryName` lookup pattern (Map-based, O(1)).
- Existing codebase `src/particles/ParticlePool.ts` -- Verified spawn API, ring buffer, MAX_PARTICLES=5000, velocity damping 0.995/frame, MAX_SPEED=5.0 cap.
- Existing codebase `src/particles/ParticleSystem.ts` -- Verified single shared pool, additive blending shader, Points mesh.
- Existing codebase `src/main.ts` -- Verified staggered inference loop (face on even frames), blendshape access at line 290, force field application at lines 439-452.
- Existing codebase `src/particles/FaceLandmarkTracker.ts` -- Verified mirrored x-coordinate: `-(lm.x * 2 - 1)` makes anatomical left = screen left.

### Secondary (MEDIUM confidence)
- [Dev.to blink detection article](https://dev.to/piko/i-built-an-ai-that-reads-my-blinks-and-speaks-morse-code-heres-the-code-18df) -- Confirmed score near 0 = eye open, near 1 = eye closed. Confirms frame-synchronized timing is better than setTimeout.
- [MediaPipe Blendshape Model Card V2](https://storage.googleapis.com/mediapipe-assets/Model%20Card%20Blendshape%20V2.pdf) -- 52 blendshape coefficients documented.

### Tertiary (LOW confidence)
- WebGL particle firework patterns (multiple web tutorials) -- Confirmed radial burst + additive blending approach. No specific code adopted.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- No new libraries; everything exists in codebase, verified by reading source files
- Architecture: HIGH -- Clear integration points identified at specific line numbers in main.ts
- Wink detection: HIGH -- Blendshape names/ranges verified from MediaPipe source; algorithm is straightforward single-threshold + cooldown
- Firework spawning: HIGH -- Uses existing proven spawn() API; radial math is basic trigonometry
- Claude's Discretion params: MEDIUM -- Speed, size, jitter values are reasoned from the scene coordinate system and existing particle parameters but need in-app visual tuning
- Pitfalls: HIGH -- Well-characterized risks with clear mitigations

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable -- no moving dependencies)
