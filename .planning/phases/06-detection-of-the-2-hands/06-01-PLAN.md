---
phase: 06-detection-of-the-2-hands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ml/HandDetector.ts
  - src/particles/ParticlePool.ts
  - src/ui/GestureOverlay.ts
  - src/main.ts
autonomous: false

must_haves:
  truths:
    - "Both hands are detected and tracked simultaneously in real-time"
    - "Each hand independently recognizes gestures (push, attract) and applies forces from its own position"
    - "Two-handed interactions create visually distinct combined effects (push-push = compound explosion, push-attract = tug-of-war, attract-attract = two orbits)"
    - "Performance remains at 30+ FPS with dual-hand tracking active alongside face/emotion detection"
    - "Removing one hand decays its gesture smoothly while the other continues independently"
  artifacts:
    - path: "src/ml/HandDetector.ts"
      provides: "Dual-hand detection config"
      contains: "numHands: 2"
    - path: "src/particles/ParticlePool.ts"
      provides: "Velocity magnitude cap preventing extreme dual-force velocities"
      contains: "MAX_SPEED"
    - path: "src/ui/GestureOverlay.ts"
      provides: "Per-hand gesture labels (L/R)"
      contains: "updateDual"
    - path: "src/main.ts"
      provides: "Dual GestureState instances, dual hand iteration, dual auras, dual force fields"
      contains: "gestureStates"
  key_links:
    - from: "src/main.ts"
      to: "src/ml/HandDetector.ts"
      via: "handDetector.detect() returning 0-2 hands"
      pattern: "handResult\\.landmarks\\.length"
    - from: "src/main.ts"
      to: "src/state/GestureState.ts"
      via: "Two GestureState instances keyed by handedness"
      pattern: "gestureStates\\.get"
    - from: "src/main.ts"
      to: "src/particles/ParticlePool.ts"
      via: "applyForceField called once per active hand"
      pattern: "applyForceField"
    - from: "src/main.ts"
      to: "src/ui/GestureOverlay.ts"
      via: "Per-hand gesture update"
      pattern: "gestureOverlay.*update"
---

<objective>
Upgrade the single-hand gesture pipeline to support two simultaneous hands, each with independent gesture recognition and force field application.

Purpose: Enable two-handed particle manipulation â€” the user can push with one hand and attract with the other, creating visually distinct combined effects (tug-of-war, compound explosions, dual orbits).

Output: Working dual-hand detection with independent gestures, dual auras, dual force fields, velocity safety cap, and per-hand overlay labels.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-detection-of-the-2-hands/06-RESEARCH.md

@src/ml/HandDetector.ts
@src/state/GestureState.ts
@src/ml/GestureClassifier.ts
@src/ui/GestureOverlay.ts
@src/particles/ParticlePool.ts
@src/main.ts
@src/core/types.ts
@src/core/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable dual-hand detection and add velocity cap</name>
  <files>src/ml/HandDetector.ts, src/particles/ParticlePool.ts</files>
  <action>
    **HandDetector.ts:**
    - Change `numHands: 1` to `numHands: 2` in the `createFromOptions` call (line 37).
    - Update the JSDoc comment at the top: change "single-hand detection (numHands: 1)" to "dual-hand detection (numHands: 2)".
    - No other changes needed. The `detect()` method already returns `HandLandmarkerResult` which naturally contains 0, 1, or 2 hand entries in `landmarks[]` and `handedness[]`.

    **ParticlePool.ts:**
    - Add a velocity magnitude cap in the `update()` method, AFTER the velocity damping step (after `*= 0.995` lines).
    - Cap logic:
      ```typescript
      const vx = this.velocities[i3];
      const vy = this.velocities[i3 + 1];
      const speed = Math.sqrt(vx * vx + vy * vy);
      const MAX_SPEED = 5.0; // scene units per second
      if (speed > MAX_SPEED) {
        const scale = MAX_SPEED / speed;
        this.velocities[i3] *= scale;
        this.velocities[i3 + 1] *= scale;
      }
      ```
    - Place `MAX_SPEED` as a const at the top of the file (module-level), not inside the method. Value: `5.0`.
    - This prevents particles from flying off-screen when two force fields overlap (both pushing or push+attract tug-of-war).
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors.
    - Grep confirms `numHands: 2` in HandDetector.ts.
    - Grep confirms `MAX_SPEED` in ParticlePool.ts.
  </verify>
  <done>HandDetector configured for 2 hands. ParticlePool has velocity safety cap preventing extreme dual-force velocities.</done>
</task>

<task type="auto">
  <name>Task 2: Dual-hand GestureOverlay and main.ts pipeline integration</name>
  <files>src/ui/GestureOverlay.ts, src/main.ts</files>
  <action>
    **GestureOverlay.ts -- update to show per-hand labels (L/R):**
    - Change the `update()` method signature to accept two gestures:
      `update(leftGesture: GestureType, rightGesture: GestureType): void`
      where "left"/"right" refer to the USER's perspective (MediaPipe "Left" = user's right hand due to camera mirror).
    - Build the display text: `L: ${GESTURE_LABELS[rightGesture]} / R: ${GESTURE_LABELS[leftGesture]}`
      (MediaPipe "Left" maps to user's Right, MediaPipe "Right" maps to user's Left -- swap for display).
    - Only update DOM when the combined text changes (track with a `prevText: string` instead of `prevGesture`).
    - Toggle `gesture-overlay--active` class if EITHER gesture is not 'none'.
    - Remove the old `prevGesture` field, replace with `private prevText = ''`.

    **main.ts -- dual pipeline integration (this is the core change):**

    Replace the single `gestureState` with a Map of two instances:
    ```typescript
    const gestureStates = new Map<string, GestureState>([
      ['Left', new GestureState()],
      ['Right', new GestureState()],
    ]);
    ```

    Replace the single `handAura` with a Map of two auras:
    ```typescript
    const handAuras = new Map<string, HTMLDivElement>();
    for (const label of ['Left', 'Right']) {
      const aura = document.createElement('div');
      aura.className = 'hand-aura';
      app.appendChild(aura);
      handAuras.set(label, aura);
    }
    ```
    Remove the old single `handAura` variable declaration at module scope and the old single `handAura` creation code.

    **HAND frame (odd) in the render loop -- replace the single-hand block:**
    ```typescript
    // HAND frame (odd)
    const handDt = Math.min(now - lastHandTime, 0.15);
    lastHandTime = now;

    const handResultData = handDetector!.detect(video!);
    const seenHands = new Set<string>();

    if (handResultData !== null && handResultData.landmarks.length > 0) {
      for (let i = 0; i < handResultData.landmarks.length; i++) {
        const handedness = handResultData.handedness[i][0].categoryName; // "Left" or "Right"

        // Guard: skip if we already processed a hand with this label this frame
        // (MediaPipe may misclassify both hands as same handedness ~5% of frames)
        if (seenHands.has(handedness)) continue;
        seenHands.add(handedness);

        const landmarks = handResultData.landmarks[i];
        const rawGesture = classifyGesture(landmarks);
        const palmCenter = getPalmCenter(landmarks);
        const palmSceneX = -(palmCenter.x * 2 - 1) * aspect;
        const palmSceneY = -(palmCenter.y * 2 - 1);

        const state = gestureStates.get(handedness);
        if (state) {
          state.update(rawGesture, true, { x: palmSceneX, y: palmSceneY }, handDt);
        }
      }
    }

    // Hands NOT seen this frame: update with no detection (triggers decay)
    for (const [label, state] of gestureStates) {
      if (!seenHands.has(label)) {
        state.update('none', false, null, handDt);
      }
    }
    ```

    **Face frame occlusion check -- update to check ANY hand active:**
    Replace `const gestureNow = gestureState.getCurrent();` and its check with:
    ```typescript
    let anyHandActive = false;
    for (const [, state] of gestureStates) {
      const r = state.getCurrent();
      if (r.active && r.handPosition) { anyHandActive = true; break; }
    }
    if (anyHandActive) {
      // Occlusion: hand present + face lost = freeze last emotion
    } else {
      emotionState.decayToNeutral();
      lastFaceLandmarks = undefined;
    }
    ```

    **Gesture result reading -- replace single read with per-hand reads:**
    Replace `const gestureResult = gestureState.getCurrent();` with reading both states for the force field and aura sections.

    **Spawn velocity reduction -- check if ANY gesture is active:**
    Replace `const gestureActive = gestureResult.active;` with:
    ```typescript
    let gestureActive = false;
    for (const [, state] of gestureStates) {
      if (state.getCurrent().active) { gestureActive = true; break; }
    }
    ```

    **Force field section -- apply per hand:**
    Replace the single `if (gestureResult.active...)` block with:
    ```typescript
    const forceStrengths: Record<GestureType, number> = {
      push: FORCE_PUSH_STRENGTH,
      attract: FORCE_ATTRACT_STRENGTH,
      none: 0,
    };
    const influenceRadius = (GESTURE_INFLUENCE_PX / window.innerHeight) * 2.0;

    for (const [, state] of gestureStates) {
      const result = state.getCurrent();
      if (result.active && result.handPosition) {
        const effectiveStrength = forceStrengths[result.gesture] * result.strength;
        particleSystem!.getPool().applyForceField(
          result.handPosition.x,
          result.handPosition.y,
          result.gesture,
          influenceRadius,
          effectiveStrength,
          dt,
        );
      }
    }
    ```

    **Gesture overlay update -- pass both hand states:**
    Replace `gestureOverlay!.update(gestureResult.gesture);` with:
    ```typescript
    const leftResult = gestureStates.get('Left')!.getCurrent();
    const rightResult = gestureStates.get('Right')!.getCurrent();
    gestureOverlay!.update(leftResult.gesture, rightResult.gesture);
    ```

    **Hand aura section -- position each aura independently:**
    Replace the single handAura block with:
    ```typescript
    for (const [label, aura] of handAuras) {
      const result = gestureStates.get(label)!.getCurrent();
      if (result.active && result.handPosition) {
        const screenX = (1 - (result.handPosition.x / aspect + 1) / 2) * window.innerWidth;
        const screenY = (1 - (result.handPosition.y + 1) / 2) * window.innerHeight;
        const auraSizePx = GESTURE_INFLUENCE_PX * 2;
        aura.style.left = `${screenX}px`;
        aura.style.top = `${screenY}px`;
        aura.style.width = `${auraSizePx}px`;
        aura.style.height = `${auraSizePx}px`;
        aura.classList.add('hand-aura--visible');
      } else {
        aura.classList.remove('hand-aura--visible');
      }
    }
    ```

    **Overlay toggle button -- update to hide both auras:**
    Replace the single `if (handAura) handAura.style.display = display;` with:
    ```typescript
    for (const [, aura] of handAuras) {
      aura.style.display = display;
    }
    ```

    **HMR cleanup -- update for dual state:**
    Remove the single `handAura` cleanup block. Replace with:
    ```typescript
    for (const [, aura] of handAuras) {
      aura.remove();
    }
    handAuras.clear();
    ```
    Remove `gestureState` reset if any explicit cleanup exists (GestureState has no dispose method, so just removing references is fine).

    **Module-scope variables:** Remove the single `let handAura: HTMLDivElement | null = null;` line. The handAuras Map is function-scoped in `loadAndConnect`.

    **Important: Do NOT modify:**
    - `GestureState.ts` -- class is already fine, just create two instances
    - `GestureClassifier.ts` -- pure function, called per hand
    - `types.ts` -- existing types are sufficient
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors.
    - Grep for `gestureStates` in main.ts confirms dual state map.
    - Grep for `seenHands` in main.ts confirms same-handedness guard.
    - Grep for `handAuras` in main.ts confirms dual aura map.
    - Grep for `update(leftGesture` in GestureOverlay.ts confirms dual signature.
  </verify>
  <done>
    main.ts iterates over 0-2 detected hands per frame, routes each to the correct GestureState by handedness label, applies force fields independently per active hand, positions two separate hand auras, and passes per-hand gestures to the overlay. Same-handedness guard prevents duplicate processing. Unseen hands decay properly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Dual-hand detection and gesture pipeline:
    1. Both hands detected simultaneously (numHands: 2)
    2. Each hand independently recognizes push (open hand) and attract (fist)
    3. Two hand auras positioned independently
    4. Force fields apply per hand -- combined effects visible
    5. Gesture overlay shows L/R labels
    6. Velocity cap prevents particles flying off-screen
    7. Single-hand still works as before (backwards compatible)
  </what-built>
  <how-to-verify>
    1. Run `npm run dev` and open the app in Chrome
    2. Grant camera access and wait for loading to complete

    **Single-hand test (backwards compatibility):**
    3. Show one open hand -- particles should push away from hand position with aura visible
    4. Make a fist -- particles should orbit/attract toward fist
    5. Remove hand -- gesture should decay smoothly (aura fades)

    **Dual-hand test:**
    6. Show BOTH hands open -- two auras visible, particles pushed from both positions (compound explosion)
    7. Both fists -- two attract orbits visible simultaneously
    8. One open hand + one fist -- tug-of-war: particles pushed by one hand, attracted by the other
    9. Remove one hand -- its aura fades while other hand continues working independently

    **Overlay test:**
    10. Check top-left overlay shows "L: Push / R: Attract" (or similar) with correct hand mapping
    11. Toggle overlays button -- both auras and overlay should hide/show together

    **Performance test:**
    12. With both hands active, check stats.js shows 30+ FPS
    13. Particles should not fly off-screen even when both hands push from nearby positions (velocity cap)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` compiles without errors
- App loads and runs at 30+ FPS with dual-hand tracking
- Both hands independently detect gestures and apply force fields
- Gesture overlay shows per-hand labels (L/R)
- Two hand auras render and position independently
- Velocity cap prevents particles from extreme speeds
- Single-hand usage works identically to before (no regression)
- Same-handedness guard prevents duplicate hand processing
</verification>

<success_criteria>
- Both hands detected and tracked simultaneously in real-time
- Each hand independently recognizes push/attract and applies its own force field
- Two-handed interactions produce visually distinct combined effects (push-push, push-attract, attract-attract)
- Performance stays at 30+ FPS with dual-hand tracking + face/emotion detection
- Gesture overlay displays per-hand gesture labels
- Removing one hand decays its effect while the other continues
</success_criteria>

<output>
After completion, create `.planning/phases/06-detection-of-the-2-hands/06-01-SUMMARY.md`
</output>
